

# 分布式架构设计和微服务深入

## 接口设计原则

### 开闭原则

对扩展开放，对修改封闭。

### 依赖倒置原则

高层模块不应该依赖底层模块，抽象不应该依赖细节，细节应该依赖抽象。

### 单一职责原则

应该有且仅有一个原因引起类的变更。

### 迪米特法则

一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解,只和朋友通信，不和陌生人说话。

### 里氏替换原则

只要父类能出现的地方子类都可以出现，而且替换为子类也不会产生任何错误或异常。

### 接口隔离原则

客户端不应该依赖它不需要的接口。类间的依赖关系应该建立在最小的接口上。

### 合成复用原则

它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

## 设计模式

[设计模式 | 菜鸟教程 (runoob.com)](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)

### 工厂模式

工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

![工厂模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg)

### 抽象工厂模式

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

![抽象工厂模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg)

### 单例模式

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

**注意：**

- 1、单例类只能有一个实例。
- 2、单例类必须自己创建自己的唯一实例。
- 3、单例类必须给所有其他对象提供这一实例。

![单例模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/62576915-36E0-4B67-B078-704699CA980A.jpg)

### 建造者模式

建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

![建造者模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-builder-pattern.svg)

### 原型模式

原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

![原型模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201202-prototype-pattern.png)

### 适配器模式

适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。

![适配器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201204-adapter.png)

### 桥接模式

桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。

这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。

![桥接模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-bridge.svg)

### 过滤器模式

过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。

![过滤器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-filter-md-20201230.svg)

### 组合模式

组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

![组合模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-composite.svg)

### 装饰器模式

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

![装饰器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-decorator.svg)

### 外观模式

外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。

这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

![外观模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-facade.svg)

### 享元模式

享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。

![享元模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-fiyweight.svg)

### 代理模式

在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。

在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。

![代理模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-proxy.svg)

### 责任链模式

顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。

在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

![责任链模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-chain-of-responsibility.svg)

### 命令模式

命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。

![img](https://www.runoob.com/wp-content/uploads/2014/08/20201015-command-1.svg)

### 解释器模式

解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。

![解释器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/interpreter_pattern_uml_diagram.jpg)

### 迭代器模式

迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

迭代器模式属于行为型模式。

![迭代器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/iterator_pattern_uml_diagram.jpg)

### 中介者模式

中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。

![中介者模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/mediator_pattern_uml_diagram.jpg)

### 备忘录模式

备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。

![备忘录模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/memento_pattern_uml_diagram.jpg)

### 观察者模式

当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。

![观察者模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/observer_pattern_uml_diagram.jpg)

### 状态模式

在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。

在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。

![状态模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/state_pattern_uml_diagram.png)

### 空对象模式

在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。

在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。

![空对象模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/null_pattern_uml_diagram.jpg)

### 策略模式

在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。

在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。

![策略模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg)

### 模板模式

在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。

![模板模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/template_pattern_uml_diagram.jpg)

### 访问者模式

在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。

![访问者模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/visitor_pattern_uml_diagram.jpg)

## 分布式架构演进

![img](https://pic1.zhimg.com/80/v2-d823f0a8e2ae3f3f129484ffa8369e45_720w.jpg?source=1940ef5c)

### 单体

在项目中，我们通常将需求分为三个部分：**数据库、服务器处理、前端展示**。如果这些需求都实现在了同一个应用中，那么这个项目就是单体架构的。在项目发展初期，由于所有的业务逻辑写在一个应用中，开发、测试、部署变得简单高效。但是，随着业务不断扩大、需求不断增多，代码会越来越臃肿，系统变得难以维护。试想，当只需要修改一个很小的功能时，由于所以功能模块都写在同一个应用，重新部署会影响其他功能正常运行。另外，当项目太过庞大臃肿时，系统优化也是一道难题。每个功能模块的并发量、使用场景、消耗的资源类型都不同，但是它们都在同一个应用中，这就使得我们对各个功能模块的容量很难做出评估，难以对个别模块进行优化。

### 垂直架构

MVC

### 分布式

将不同功能，或不同地点，或拥有不同数据的多台计算机通过网络连接起来，由控制系统统一管理，完成大规模信息处理的计算机系统。

### 集群

将多台服务器集中在一起提供同一种服务，在逻辑上可以看做是一台服务器对外进行服务，这些服务器组合就是集群。

### 分布式和集群的区别

1、从概念上就可以看出两者最主要的区别就是分布式是将一种业务拆分成多个子业务部署在多台服务器上，进而对外提供服务；而集群就是将多台服务器组合在一起提供同一种服务；

2、集群强调在多台服务器位置集中，并且容易统一管理；而分布式没有具体要求，不论放置在哪个位置，只要通过网络连接起来就行；

3、集群是一种物理形态，即多台服务器在一起提供一种服务；而分布式是一种工作方式，即一个程序或业务分解到多台服务器分别完成；

## 分布式架构理论

### 分布式系统概念

[分布式系统的概念都搞懂了吗？（上） - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1673473)

[分布式系统的概念都搞懂了吗？（下） - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1676820)

#### 进程

计算机的核心是CPU，它承担了所有的计算任务，而操作系统是计算机的管理者，它负责任务的调度，资源的分配和管理，统领整个计算机硬件；应用程序是具有某种功能的程序，程序是运行于操作系统之上的。

进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。进程一般由程序，数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块包含进程的描述信息和控制信息是进程存在的唯一标志

进程具有的特征：

动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；

并发性：任何进程都可以同其他进行一起并发执行；

独立性：进程是系统进行资源分配和调度的一个独立单位；

结构性：进程由程序，数据和进程控制块三部分组成

#### 线程

在早期的操作系统中并没有线程的概念，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片

轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。

　　后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明

了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或

多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID，当前指令指针PC，寄存器和堆栈组

成。而进程由内存空间(代码，数据，进程空间，打开的文件)和一个或多个线程组成。

**进程与线程的区别**

1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；

2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线

3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；

4. 调度和切换：线程上下文切换比进程上下文切换要快得多

#### 并发

当有多个线程在操作时，如果系统只有一个CPU，则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其他线程处于挂起状态。这种方式我们称之为并发（Concurrent）

应用层的并发概念可以推广之，定义为单位时间内对于共享资源的访问，比如在数据库单条记录更新时，一条在更新，一条并发请求则处于等待状态。

#### 并行

当系统有一个以上的CPU时，则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行（Parallel）。

和并发的区别：并发和并行是即相似又有区别的两个概念，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。

**并发与并行的区别**

并发是两个队列交替使用一台咖啡机，并行是两个队列同时使用两台咖啡机。

![img](https://pic1.zhimg.com/80/v2-674f0d37fca4fac1bd2df28a2b78e633_720w.jpg?source=1940ef5c)

#### 集群

集群是一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理。一个客户与集群相互作用时，集群像是一个独立的服务器。集群配置是用于提高可用性和可伸缩性。其实，分布式系统可以表达为很多机器组成的集群，靠彼此之间的网络通信，担当的角色可能不同，共同完成同一件事情的系统。可以划分为以下几种类型：

（1）节点：系统中按照协议完成计算工作的一个逻辑实体，可能是执行某些工作的进程或机器。

（2）网络：系统的数据传输通道，用来彼此通信。通信是具有方向性的。

（3）存储：系统中持久化数据的数据库或者[文件存储](https://cloud.tencent.com/product/cfs?from=10680)。

根据典型的集群体系结构，集群中涉及的关键技术可以归属于四个层次：

（1）网络层：网络互联结构、通信协议、信号技术等。

（2）节点机及操作系统层高性能客户机、分层或基于微内核的操作系统等。

（3）集群系统管理层：资源管理、资源调度、负载平衡、并行IPO、安全等。

（4）应用层：并行程序开发环境、串行应用、并行应用等。

#### 锁

锁的含义，一般就是为了独占资源，防止并发冲突，一般锁的实现，都依赖于计算机资源，如CPU，内存等，但是在跨系统时，各系统独立，如果需要锁，就需要一种分布式锁的实现方案。让各系统之间对相同资源的并发操作不会出现并发问题。

减少或规避锁争用的几种策略：

（1）分拆锁；

（2）分离锁；

（3）避免共享变量缓存；

（4）使用并发容器如Amino；

#### 状态特性

##### 无状态服务（stateless service）

对单次请求的处理，不依赖其他请求，也就是说，处理一次请求所需的全部信息，要么都包含在这个请求里，要么可以从外部获取到（比如说数据库），服务器本身不存储任何信息

##### 有状态服务（stateful service）

对请求的处理，它会在自身保存一些数据，先后的请求是有关联的。

**状态服务于无状态服务比较**

- 单体条件下面，服务只有一个，因此状态每个时刻也就只有一种状态。在分布式集群环境下面，就存在一个状态同步问题，因此也有**有状态服务设计**和**无状态服务设计**。比如session，如果session保存在每一台服务器上，那么就是有状态设计，可能会出现集群内，服务状态不一致的现象；如果session由专门的一台服务器来保存，就是无状态设计，服务不保存状态，需要的时候从同一的服务器中获取，保证了服务在任何时刻的状态一致。
- 有状态的服务，会有比较明显的缺点，服务间数据需要同步，成为副本关系，逻辑复杂也浪费资源 ；无状态的应用服务器，不保存上下文信息，只负责对用户的每次请求提交数据进行处理然后返回处理结果 无状态应用服务器之间是对等的关系，无依赖，请求到哪个服务器，处理结果都一样的。

![img](https://pic4.zhimg.com/80/v2-16623aff7c82e4ca8d64ef63e62aca17_720w.jpg)

#### 系统重发与幂等性

重发（retry）的机制，我们要考虑幂等性设计。所谓幂等性就是调用1次和调用N次要返回一样的结果。

#### 硬件异常

一套提供给客户的运行系统包括硬件和软件，而硬件则涉及机房、网络、服务器、磁盘及其他存储设备等等。硬件异常就是硬件出现了问题，而导致运行程序部分不可用或者全部不可用。

1.服务器宕机

2.网络异常

3.磁盘故障

4.房级异常

### 分布式系统理论

#### CAP理论

[CAP理论的理解 - John_nok - 博客园 (cnblogs.com)](https://www.cnblogs.com/mingorun/p/11025538.html)

CAP理论作为分布式系统的基础理论,它描述的是一个分布式系统在以下三个特性中：

- 一致性（**C**onsistency）
- 可用性（**A**vailability）
- 分区容错性（**P**artition tolerance）

最多满足其中的两个特性。也就是下图所描述的。分布式系统要么满足CA,要么CP，要么AP。无法同时满足CAP。

　　　　　　　　![img](https://img2018.cnblogs.com/blog/941183/201906/941183-20190614191945691-976367436.png)

 

 

**I.** 什么是 一致性、可用性和分区容错性

**分区容错性**：指的分布式系统中的某个节点或者网络分区出现了故障的时候，整个系统仍然能对外提供满足一致性和可用性的服务。也就是说部分故障不影响整体使用。

事实上我们在设计分布式系统是都会考虑到bug,硬件，网络等各种原因造成的故障，所以即使部分节点或者网络出现故障，我们要求整个系统还是要继续使用的

(不继续使用,相当于只有一个分区,那么也就没有后续的一致性和可用性了)

 

**可用性：** 一直可以正常的做读写操作。简单而言就是客户端一直可以正常访问并得到系统的正常响应。用户角度来看就是不会出现系统操作失败或者访问超时等问题。

 

**一致性**：在分布式系统完成某写操作后任何读操作，都应该获取到该写操作写入的那个最新的值。相当于要求分布式系统中的各节点时时刻刻保持数据的一致性。

#### Paxos

[Paxos算法详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/31780743)

一种基于消息传递的分布式一致性算法。

#### 2PC

[分布式事务(1)---2PC和3PC原理 - 雨点的名字 - 博客园 (cnblogs.com)](https://www.cnblogs.com/qdhxhz/p/11167025.html)

[分布式系统理论基础 - 一致性、2PC和3PC - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/21994882)

两阶段提交又称2PC,2PC是一个非常经典的强一致、中心化的原子提交协议。

这里所说的中心化是指协议中有两类节点：一个是中心化协调者节点（coordinator）和N个参与者节点（partcipant）。

两个阶段：第一阶段：投票阶段 和第二阶段：提交/执行阶段。

![img](https://img2018.cnblogs.com/blog/1090617/201907/1090617-20190710222443794-591603727.jpg)

![img](https://img2018.cnblogs.com/blog/1090617/201907/1090617-20190710222454275-1462865655.jpg)

![img](https://img2018.cnblogs.com/blog/1090617/201907/1090617-20190710222502868-1587526642.jpg)

#### 3PC

三阶段提交协议（3PC）主要是为了解决两阶段提交协议的阻塞问题，2pc存在的问题是当协作者崩溃时，参与者不能做出最后的选择。因此参与者可能在协作者恢复之前保持阻塞。三阶段提交（Three-phase commit），是二阶段提交（2PC）的改进版本。

与两阶段提交不同的是，三阶段提交有两个改动点。

```
1、 引入超时机制。同时在协调者和参与者中都引入超时机制。
2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。
```

也就是说，除了引入超时机制之外，**3PC把2PC的准备阶段再次一分为二**，这样三阶段提交就有`CanCommit`、`PreCommit`、`DoCommit`三个阶段。

![img](https://img2018.cnblogs.com/blog/1090617/201907/1090617-20190710222512291-462809105.png)

#### Raft

[分布式系统的Raft算法 - 解道Jdon](https://www.jdon.com/artichect/raft.html)

过去, Paxos一直是分布式协议的标准，但是Paxos难于理解，更难以实现，Google的分布式锁系统Chubby作为Paxos实现曾经遭遇到很多坑。

　　来自Stanford的新的分布式协议研究称为Raft，它是一个为真实世界应用建立的协议，主要注重协议的落地性和可理解性。

　　在了解Raft之前，我们先了解Consensus一致性这个概念，它是指多个服务器在状态达成一致，但是在一个分布式系统中，因为各种意外可能，有的服务器可能会崩溃或变得不可靠，它就不能和其他服务器达成一致状态。这样就需要一种Consensus协议，一致性协议是为了确保容错性，也就是即使系统中有一两个服务器当机，也不会影响其处理过程。

　　为了以容错方式达成一致，我们不可能要求所有服务器100%都达成一致状态，只要超过半数的大多数服务器达成一致就可以了，假设有N台服务器，N/2 +1 就超过半数，代表大多数了。

Paxos和Raft都是为了实现Consensus一致性这个目标，这个过程如同选举一样，参选者需要说服大多数选民(服务器)投票给他，一旦选定后就跟随其操作。Paxos和Raft的区别在于选举的具体过程不同。

　　在Raft中，任何时候一个服务器可以扮演下面角色之一：

1. Leader: 处理所有客户端交互，日志复制等，一般一次只有一个Leader.
2. Follower: 类似选民，完全被动
3. Candidate候选人: 类似Proposer律师，可以被选为一个新的领导人。

#### Lease机制

[分布式系统原理 之3 Lease机制_从零开始-CSDN博客_lease机制](https://blog.csdn.net/u012428012/article/details/80572071)

**Lease 机制是最重要的分布式协议**，广泛应用于各种实际的分布式系统中。即使在某些系统中相似的设计不被称为 lease，但我们可以分析发现其本质就是一种 lease 的实现。

基于 lease 的分布式 cache 系统

通过一种分布式 cache 系统的实例来介绍 lease 机制。Lease 机制最初也是被运用于这种系统。

基本的问题背景如下：在一个分布式系统中，有一个中心服务器节点，中心服务器存储、维护着一些数据，这些数据是系统的元数据。系统中其他的节点通过访问中心服务器节点读取、修改其上的元数据。由于系统中各种操作都依赖于元数据，如果每次读取元数据的操作都访问中心服务器节点，那么中心服务器节点的性能成为系统的瓶颈。为此，设计一种元数据 cache，在各个节点上cache 元数据信息，从而减少对中心服务器节点的访问，提高性能。另一方面，系统的正确运行严格依赖于元数据的正确，这就要求各个节点上 cache 的数据始终与中心服务器上的数据一致，cache中的数据不能是旧的脏数据。最后，设计的 cache 系统要能最大可能的处理节点宕机、网络中断等异常，最大程度的提高系统的可用性。

为此，利用 lease 机制设计一套 cache 系统，其基本原理为如下。中心服务器在向各节点发送数据时同时向节点颁发一个 lease。每个 lease 具有一个有效期，和信用卡上的有效期类似，lease 上的有效期通常是一个明确的时间点，例如 12:00:10，一旦真实时间超过这个时间点，则 lease 过期失效。这样 lease 的有效期与节点收到 lease 的时间无关，节点可能收到 lease 时该 lease 就已经过期失效。这里首先假设中心服务器与各节点的时钟是同步的，下节中讨论时钟不同步对 lease 的影响。中心服务器发出的 lease 的含义为：在 lease 的有效期内，中心服务器保证不会修改对应数据的值。因此，节点收到数据和 lease 后，将数据加入本地 Cache，一旦对应的 lease 超时，节点将对应的本地 cache数据删除。中心服务器在修改数据时，首先阻塞所有新的读请求，并等待之前为该数据发出的所有lease 超时过期，然后修改数据的值。

#### 解决“脑裂”问题

[脑裂问题以及如何避免_u014156013的博客-CSDN博客_脑裂问题](https://blog.csdn.net/u014156013/article/details/81226424)

脑裂（brain-split）：脑裂是指在主备切换时，由于切换不彻底或其他原因，导致客户端和Slave误以为出现两个active master，最终使得整个集群处于混乱状态。解决脑裂问题，通常采用隔离(Fencing)机制，包括三个方面：

​    共享存储fencing：确保只有一个Master往共享存储中写数据。

​    客户端fencing：确保只有一个Master可以响应客户端的请求。

​    Slave fencing：确保只有一个Master可以向Slave下发命令。

#### Quorum NWR

[分布式Quorum机制,NWR策略读写模型_大树叶 技术专栏-CSDN博客](https://blog.csdn.net/bigtree_3721/article/details/76805103)

[Quorum NWR_很不错的 blog-CSDN博客](https://blog.csdn.net/zgl_dm/article/details/6291664)

WR是一种在分布式存储系统中用于控制一致性级别的一种策略。在Amazon的Dynamo云存储系统中，就应用NWR来控制一致性。

这三个字母的含义：

N：同一份数据的Replica的份数
W：是更新一个数据对象的时候需要确保成功更新的份数
R： 读取一个数据需要读取的Replica的份数

NWR值的不同组合会产生不同的一致性效果，当W+R>N的时候，整个系统对于客户端来讲能保证强一致性。当W+R<N的时候只能保证最终一致性。

#### MVCC

[MVCC多版本并发控制 - 简书 (jianshu.com)](https://www.jianshu.com/p/8845ddca3b23)

MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。

多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题

- 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
- 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题

#### Gossip

[P2P 网络核心技术：Gossip 协议 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/41228196)

Gossip protocol 也叫 Epidemic Protocol （流行病协议），实际上它还有很多别名，比如：“流言算法”、“疫情传播算法”等。

Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。

![img](https://pic4.zhimg.com/v2-575e785e7d03ad317e5bce4e36debb03_b.jpg)

**Gossip 的特点（优势）**

**1）扩展性**

网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。

**2）容错**

网络中任何节点的宕机和重启都不会影响 Gossip 消息的传播，Gossip 协议具有天然的分布式系统容错特性。

**3）去中心化**

Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。

**4）一致性收敛**

Gossip 协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN。

**5）简单**

Gossip 协议的过程极其简单，实现起来几乎没有太多复杂性。

**Gossip 的缺陷**

分布式网络中，没有一种完美的解决方案，Gossip 协议跟其他协议一样，也有一些不可避免的缺陷，主要是两个：

**1）消息的延迟**

由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下。

**2）消息冗余**

Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送，因此，即使收到了消息的节点还会反复收到重复消息，加重了消息的冗余。

## 分布式架构设计策略

### 心跳检测

心跳不是服务端主动去发信息检测客户端状态，而是在服务端保存下来所有客户端的状态信息，然后等待客户端定时来访问服务端，更新自己的当前状态，如果客户端超过指定的时间没有来更新状态，则认为客户端已经宕机或者其状态异常。

### 高可用设计

**避免单点故障**

负载均衡技术（Failover、选址、硬件负载、软件负载、去中心化的软件负载（Gossip（Redis- Cluster）））

热备（Linux HA）

多机房（同城灾备、异地灾备）

**应用的高可用性**

故障监控（系统监控（CPU、内存）/链路监控/日志监控）自动预警

应用的容错设计、（服务降级、限流）自我保护能力

数据量（数据分片、读写分离）

**分布式架构下的可伸缩设计**

垂直伸缩

提升硬件能力

水平伸缩

增加服务器

**加速静态内容访问速度的CDN**

CDN全称是Content Delivery Network，中文释义是内容分发网络。CDN的作用是把用户需要的内容分发到离用户最近的地方进行响应，这样用户能够快速获取所需要的内容。CDN本质上就是一种网络缓存技术，能够把一些相对稳定的资源放到距离最终用户较近的地方，一方面可以节省整个广域网的带宽消耗，另外一方面也可以提升用户的访问速度、改善用户体验。

**灰度发布**

我们的应用即使经过了测试部门的测试，也仍然很难全面覆盖用户的使用场景，为了保证万无一失，我们在进行发布的时候一般都会采用灰度发布，也就是会对新应用进行分批发布，逐步扩大新应用在整个及集群中的比例直到最后全部完成。灰度发布是说针对新应用在用户体验方面完全无感知。

灰度发布系统的作用在于，可以根据自己的配置，来将用户的流量导到新上线的系统上，来快速验证新的功能，而一旦出问题，也可以马上的回滚发布，简单的说，就是一套A/BTest系统。

### 容错性

#### FailOver:失败自动切换

失败自动切换机制是指当调用该服务集群的某个节点失败时，自动切换到该服务集群的 另外一个节点并进行重试，其中切换机制类似于负载均衡机制，不过一般采用轮询方式。这 种容错机制通常适用于读操作，所以可以请求从该服务集群的多个节点的任意一个节点获取 数据。由于需要切换到服务集群的另外一个节点进行服务重试，所以整个请求处理流程的时 间延迟会加大。

#### FailFast:快速失败

快速失败机制是指当进行服务调用失败时，直接返回错误，而不会进行重试或者切换到 服务集群的另外一个节点进行调用，即要么成功，要么失败，只发起一次服务调用请求。

这种机制通常适用于非幂等的操作，因为服务调用失败的原因包括:服务节点机器宕机 导致服务不可用;服务可用，但是两个服务节点之间的网络出现延迟或者被调用的服务节点 繁忙，处理请求缓慢，导致返回结果超时。所以当服务调用失败时，可能确实没有进行操作， 也可能是进行了操作，但是返回响应结果超时或者丢失，而该操作又是非幂等的，故不能进 行重复操作，否则会导致数据不一致性。

#### FailSafe:失败安全

失败安全机制跟快速失败机制类似，都是只发起一次服务调用，要么成功，要么失败， 不会进行重试操作。不过与快速失败不同的是，失败安全机制在调用失败时会进行日志记录。 所以可以通过对日志进行监控和分析来及时了解服务调用情况，及早发现和处理服务调用失 败的情况，以及对于重要服务的调用可以通过日志的数据来进行补偿。

#### FailBack:失败自动恢复

失败自动恢复机制在服务调用失败时，跟失败安全机制类似也会进行服务调用的记录， 不过在记录的基础上，增加了自动定时重发的逻辑，适用于异步、幂等性的请求调用或者消 息系统中允许消息重复的场景。

#### Forking:并行调用多个服务节点

并行机制通常用于实时性要求较高的读操作的场景，其基本工作过程为并行调用服务集 群的所有节点，由于是读操作，故所有服务节点返回的数据都是相同的，所以只要有一个服 务节点返回调用成功则返回响应给客户端。

这种机制相对于 FailOver 失败自动切换机制，由于是对所有服务节点发起并行调用，而 不是在调用失败时才一个个轮询切换直到调用成功，所以延迟较小，实时性较高，不过机器 的系统资源开销较大，所以如果需要进行这种调用，则需要保证机器性能较高。

#### BroadCast:广播调用

广播调用与并行调用类似，也是需要对服务集群的每个节点都发起一次调用，不过不同 的是，广播调用通常用于服务集群的每个节点都维护了本地状态，然后需要对这种本地状态 进行写操作的场景，即需要同步写操作给服务集群的每个节点，从而保证每个节点的数据一 致性和可靠性。

### 负载均衡

[分布式架构系列: 负载均衡技术详解 | 技术头条_CSDN云计算-CSDN博客_分布式负载均衡技术](https://blog.csdn.net/fl63zv9zou86950w/article/details/89078036)

负载均衡（Load Balance），意思是将负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。是解决高性能，单点故障（高可用），扩展性（水平伸缩）的终极解决方案。

统的扩展可分为纵向（垂直）扩展和横向（水平）扩展。纵向扩展，是从单机的角度通过增加硬件处理能力，比如CPU处理能力，内存容量，磁盘等方面，实现服务器处理能力的提升，不能满足大型分布式系统（网站），大流量，高并发，海量数据的问题。因此需要采用横向扩展的方式，通过添加机器来满足大型网站服务的处理能力。比如：一台机器不能满足，则增加两台或者多台机器，共同承担访问压力。这就是典型的集群和负载均衡架构：如下图：



![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/DmibiaFiaAI4B1BmaPv5pS2icDceeRH0YVTvWl982XiaQOWzam6Wf24gTd5PrEGPPO7MRcerGFcIa0U5ImqO4f6JTzg/640?wx_fmt=png)

## 分布式架构设计实践

### 全局ID生成

Web服务器深度解析及调优.集群模式.分布式ID

#### 哈希取模

[分布式中hash取模算法_evsqiezi-CSDN博客_hash取模](https://blog.csdn.net/evsqiezi/article/details/71467082)

 常用的算法是对hash结果取余数 (hash() mod N)：对机器编号从0到N-1，按照自定义的hash()算法，对每个请求的hash()值按N取模，得到余数i，然后将请求分发到编号为i的机器。但这样的算法方法存在致命问题，如果某一台机器宕机，那么应该落在该机器的请求就无法得到正确的处理，这时需要将当掉的服务器从算法从去除，此时候会有(N-1)/N的服务器的缓存数据需要重新进行计算；

为何是 (N-1)/N 呢？解释如下：
比如有 3 台机器，hash值 1-6 在这3台上的分布就是：
host 1: 1 4
host 2: 2 5
host 3: 3 6
如果挂掉一台，只剩两台，模数取 2 ，那么分布情况就变成：
host 1: 1 3 5
host 2: 2 4 6

可以看到，还在数据位置不变的只有2个： 1，2，位置发生改变的有4个，占共6个数据的比率是 4/6 = 2/3。

#### 一致性哈希

Web服务器深度解析及调优.集群模式.一致性Hash问题

### 路由表

[路由表的原理和作用_luo809976897的专栏-CSDN博客](https://blog.csdn.net/luo809976897/article/details/83584342)

路由器是一种典型的网络层设备。它在两个局域网之间按帧传输数据，在OSI／RM之中被称之为中介系统，完成网络层责在两个局域网的网络层间按帧传输数据，转发帧时需要改变帧中的地址。它在OSI／RM中的位置如图1所示。

 

![img](http://www.pep.com.cn/oldimages/import19975_1.jpg)

路由器（Router）是用于连接多个逻辑上分开的网络，所谓逻辑网络是代表一个单独的网络或者一个子网。当数据从一个子网传输到另一个子网时，可通过路由器来完成。因此，路由器具有判断网络地址和选择路径的功能，它能在多网络互联环境中，建立灵活的连接，可用完全不同的数据分组和介质访问方法连接各种子网，路由器只接受源站或其他路由器的信息，属网络层的一种互联设备。它不关心各子网使用的硬件设备，但要求运行与网络层协议相一致的软件。路由器分本地路由器和远程路由器是用业连接网络传输介质的，如光纤、同轴电缆、双绞线；远程路由器是用业连接远程传输介质，并要求相应的设备，如电话线要配调制解调器，无线要通过无线接收机、发射机。

一般说来，异种网络互联与多个子网互联都应采用路由器来完成。

路由器的主要工作就是为经过路由器的每个数据帧寻找一条最佳传输路径，并将该数据有效地传送到目的站点。由此可见，选择最佳路径的策略即路由算法是路由器的关键所在。为了完成这项工作，在路由器中保存着各种传输路径的相关数据――路径表（RoutingTable），供路由选择时使用。路径表中保存着子网的标志信息、网上路由器的个数和下一个路由器的名字等内容。路径表可以是由系统管理员固定设置好的，也可以由系统动态修改，可以由路由器自动调整，也可以由主机控制。

### 数据拆分

[分布式设计与开发（四）------数据拆分_走向架构师之路-CSDN博客](https://blog.csdn.net/cutesource/article/details/5841244)

当一个表的数据达到无法处理的时候，就需要把它拆成多个表。

**切分策略**

切分策略一般分为垂直切分、横向切分和两者的混搭。

**1）垂直切分**

垂直切分就是要把表按模块划分到不同数据库中，这种拆分在大型网站的演变过程中是很常见的。当一个网站还在很小的时候，只有小量的人来开发和维护，各模块和表都在一起，当网站不断丰富和壮大的时候，也会变成多个子系统来支撑，这时就有按模块和功能把表划分出来的需求。

其实，相对于垂直切分更进一步的是服务化改造，说得简单就是要把原来强耦合的系统拆分成多个弱耦合的服务，通过服务间的调用来满足业务需求看，因此表拆出来后要通过服务的形式暴露出去，而不是直接调用不同模块的表，淘宝在架构不断演变过程，最重要的一环就是服务化改造，把用户、交易、店铺、宝贝这些核心的概念抽取成独立的服务，也非常有利于进行局部的优化和治理，保障核心模块的稳定性。这样一种拆分方式也是有代价的：

- 表关联无法在数据库层面做
- 单表大数据量依然存在性能瓶颈
- 事务保证比较复杂
- 应用端的复杂性增加

上面这些问题是显而易见的，处理这些的关键在于如何解除不同模块间的耦合性，这说是技术问题，其实更是业务的设计问题，只有在业务上是松耦合的，才可能在技术设计上隔离开来。没有耦合性，也就不存在表关联和事务的需求。另外，大数据瓶颈问题可以参见下面要将的水平切分。

**2）水平切分**

上面谈到垂直切分只是把表按模块划分到不同数据库，但没有解决单表大数据量的问题，而水平切分就是要把一个表按照某种规则把数据划分到不同表或数据库里。例如像计费系统，通过按时间来划分表就比较合适，因为系统都是处理某一时间段的数据。而像SaaS应用，通过按用户维度来划分数据比较合适，因为用户与用户之间的隔离的，一般不存在处理多个用户数据的情况，下面是一个比较简单的按user_id来水平切分的例子：

水平切分没有破坏表之间的联系，完全可以把有关系的表放在一个库里，这样就不影响应用端的业务需求，并且这样的切分能从根本上解决大数据量的问题。它的问题也是很明显的：

- 当切分规则复杂时，增加了应用端调用的难度
- 数据维护难度比较大，当拆分规则有变化时，需要对数据进行迁移

对于第一个问题，可以参考后面要讲的如何整合应用端和数据库端。对于第二个问题可以参考一致性hash的算法，通过某些映射策略来降低数据维护的成本，可参见以前的博文[分布式设计与开发（二）------几种必须了解的分布式算法](http://blog.csdn.net/cutesource/archive/2010/08/15/5813379.aspx)

**3）垂直与水平联合切分**

由上面可知垂直切分能更清晰化模块划分，区分治理，水平切分能解决大数据量性能瓶颈问题，因此常常就会把两者结合使用，这在大型网站里是种常见的策略，这可以结合两者的优点，当然缺点就是比较复杂，成本较高，不太适合小型网站。

### 序列化技术

内存中的数据对象只有转换为二进制流才可以进行数据持久化和网络传输。将数据对象转换为二进制流的过程称为对象的序列化（Serialization）。反之，将二进制流恢复为数据对象的过程称为反序列化（Deserialization）。序列化需要保留充分的信息以恢复数据对象，但是为了节约存储空间和网络带宽，序列化后的二进制流又要尽可能小。序列化常见的使用场景是RPC框架的数据传输。常见的序列化方式有三种：

#### Java原生序列化

Java类通过实现Serializable接口来实现该类对象的序列化，这个接口非常特殊，没有任何方法，只起标识作用.Java序列化保留了对象类的元数据（如类、成员变量、继承类信息等），以及对象数据等，兼容性最好，但不支持跨语言，而且性能一般。

实现Serializable接口的类建议设置serialVersionUID字段值，如果不设置，那么每次运行时，编译器会根据类的内部实现，包括类名、接口名、方法和属性等来自动生成serialVersionUID。如果类的源代码有修改，那么重新编译后serial VersionUID的取值可能会发生变化。因此实现Serializable接口的类一定要显式地定义serialVersionUID属性值。修改类时需要根据兼容性决定是否修改serialVersionUID值：
 1.如果是兼容升级，请不要修改serialVersionUID字段，避免反序列化失败。

2.如果是不兼容升级，需要修改serialVersionUID值，避免反序列化混乱。

使用Java原生序列化需注意，Java反序列化时不会调用类的无参构造方法，而是调用native方法将成员变量赋值为对应类型的初始值。基于性能及兼容性考虑，不推荐使用Java 原生序列化。



![img](https:////upload-images.jianshu.io/upload_images/13226573-ee3386b9034c1a97.png?imageMogr2/auto-orient/strip|imageView2/2/w/692/format/webp)

Java原生序列化

#### Hessian 序列化

Hessian 序列化是一种支持动态类型、跨语言、基于对象传输的网络协议。 Java 对象序列化的二进制流可以被其他语言 （ 如 C＋＋、 Python ）反序列化。 Hessian 协议具有如下特性

．自描述序列化类型。不依赖外部描述文件或接口定义 ， 用一个字节表示常用基础类型 ， 极大缩短二进制流。
 · 语言无关，支持脚本语言。
 · 协议简单，比 Java 原生序列化高效。
 相比 Hessian 1.0, Hessian 2.0 中增加了压缩编码，其序列化二进制流大小是 Java序列化的 50% ， 序列化耗时是 Java 序列化的 30% ，反序列化耗时是 Java 反序列化的20% 。
 Hessian 会把复杂对象所有属性存储在一个 Map 申 进行序列化。所以在父类、子类存在同名成员变量的情况下， Hessian 序列化时，先序列化子类 ，然后序列化父类，因此反序列化结果会导致子类同名成员变量被父类的值覆盖。

![img](https:////upload-images.jianshu.io/upload_images/13226573-c306306949bf3dee.png?imageMogr2/auto-orient/strip|imageView2/2/w/1103/format/webp)

阿里首选的序列化方式

#### Json序列化

JSON ( JavaScript O同ect Notation ）是一种轻量级的数据交换格式。 JSON 序列化就是将数据对象转换为 JSON 字符串。在序列化过程中抛弃了类型信息，所以反序列化时只有提供类型信息才能准确地反序列化。相比前两种方式，JSON 可读性比较好，方便调试。序列化通常会通过网络传输对象 ， 而对象中往往有敏感数据，所以序列化常常成为黑客的攻击点，攻击者巧妙地利用反序列化过程构造恶意代码，使得程序在反序列化的过程中执行任意代码。 Java 工程中广泛使用的 Apache Commons Collections 、Jackson 、 fastjson 等都出现过反序列化漏洞。如何防范这种黑客攻击呢？有些对象的敏感属性不需要进行序列化传输 ，可以加 transient 关键字，避免把此属性信息转化为序列化的二进制流。如果一定要传递对象的敏感属性，可以使用对称与非对称加密方式独立传输，再使用某个方法把属性还原到对象中。应用开发者对序列化要有一定的安全防范意识 ， 对传入数据的内容进行校验或权限控制，及时更新安全漏洞，避免受到攻击。

#### 其他

hessian、XML、protobuf、kryo、msgpack、 FST、thrift、protostuff、avro。

## 分布式架构通信基础

### BIO、NIO、AIO

**BIO (Blocking I/O):** 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。

**NIO (New I/O):** NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 `Socket` 和 `ServerSocket` 相对应的 `SocketChannel` 和 `ServerSocketChannel` 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发

**AIO (Asynchronous I/O):** AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。

### Netty

[Netty: Home](https://netty.io/)

[Netty入门教程——认识Netty - 简书 (jianshu.com)](https://www.jianshu.com/p/b9f3f6a16911)

[通俗地讲，Netty 能做什么？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/24322387/answer/282001188)

Netty 是一个利用 Java 的高级网络的能力，隐藏其背后的复杂性而提供一个易于使用的 API 的客户端/服务器框架。
 Netty 是一个广泛使用的 Java 网络编程框架。它活跃和成长于用户社区，像大型公司 Facebook 和 Instagram 以及流行 开源项目如 Infinispan, HornetQ, Vert.x, Apache Cassandra 和 Elasticsearch 等，都利用其强大的对于网络抽象的核心代码。

1. **并发高**
2. **传输快**
3. **封装好**

### ByteBuf

[ByteBuf和Channel和Pipeline_weixin_30748995的博客-CSDN博客](https://blog.csdn.net/weixin_30748995/article/details/102229900)

ByteBuf就是JDK nio中Buffer的新轮子
buffer 的主要目的进行流量整形，把突发的大数量较小规模的 I/O 整理成平稳的小数量较大规模的 I/O，以**减少响应次数**

> ByteBuffer:
>
> 1. 长度固定，一旦分配完成，它的容量不能动态扩展和收缩，当需要编码的POJO对象大于ByteBuffer的容量时，会发生索引越界异常；
> 2. ByteBuffer只有一个标识位控的指针position,读写的时候需要手工调用flip()和rewind()等，使用者必须小心谨慎地处理这些API,否则很容易导致程序处理失败；
> 3. ByteBuffer的API功能有限，一些高级和实用的特性它不支持，需要使用者自己编程实现。

### Pipeline

Pipeline模式在分布式框架中经常可以看到，应用该模式可以使框架具有良好的灵活性。当我们需要构建一个系统用于处理并转换一串输入数据时，如果通过一个大的组件按部就班的来实现此功能，那么一旦需求发生变化，比如其中的两个处理步骤需要调换次序，或者需要加入或减去某些处理，系统将很难适应，甚至需要重写。而Pipeline模式则将一个个的处理模块相互分离，各自独立，然后按照需要将它们串联起来即可，此时前者的输出就会作为后者的输入。此时，每个处理模块都可以获得最大限度的复用。当需求发生变化时，我们只需重新组织各个处理模块的链接顺序，或者删除或加入新的处理模块即可。

### 分布式通信框架RMI

[分布式架构基础:Java RMI详解 - 简书 (jianshu.com)](https://www.jianshu.com/p/de85fad05dcb)

[远程方法调用（RMI）原理与示例 - Pickle - 博客园 (cnblogs.com)](https://www.cnblogs.com/wxisme/p/5296441.html)

**Java RMI**，即 **远程方法调用**([Remote Method Invocation](https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDistributed_object_communication))，一种用于实现**远程过程调用**(RPC)[(Remote procedure call)](https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FRemote_procedure_call)的Java API， 能直接传输序列化后的Java对象和[分布式垃圾收集](https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDistributed_Garbage_Collection)。它的实现依赖于[Java虚拟机](https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FJava_Virtual_Machine)(JVM)，因此它仅支持从一个JVM到另一个JVM的调用。

![img](https://upload-images.jianshu.io/upload_images/12696746-07f8e95ec97df9dd.png?imageMogr2/auto-orient/strip|imageView2/2/w/656/format/webp)

## Zookeeper

https://zookeeper.apache.org/

[1.0 Zookeeper 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/zookeeper-tutorial.html)

ZooKeeper 是 Apache 软件基金会的一个软件项目，它为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。

ZooKeeper 的架构通过冗余服务实现高可用性。

Zookeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。

一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。

zookkeeper 提供的名称空间非常类似于标准文件系统，key-value 的形式存储。名称 key 由斜线 **/** 分割的一系列路径元素，zookeeper 名称空间中的每个节点都是由一个路径标识。

![img](https://www.runoob.com/wp-content/uploads/2020/09/zknamespace.jpg)

### 安装配置

将 conf 目录下的 zoo_sample.cfg 文件，复制一份，重命名为 zoo.cfg:

![img](https://www.runoob.com/wp-content/uploads/2020/09/zk6.png)

在安装目录下面新建一个空的 data 文件夹和 log 文件夹:

![img](https://www.runoob.com/wp-content/uploads/2020/09/zk8-setup.png)

修改 zoo.cfg 配置文件，将 dataDir=/tmp/zookeeper 修改成 zookeeper 安装目录所在的 data 文件夹，再添加一条添加数据日志的配置(需要根据自己的安装路径修改)。

![img](https://www.runoob.com/wp-content/uploads/2020/09/zk9-setup.png)

双击 zkServer.cmd 启动程序:

![img](https://www.runoob.com/wp-content/uploads/2020/09/zk10-setup.png)

控制台显示 **bind to port 0.0.0.0/0.0.0.0:2181**，表示服务端启动成功!

![img](https://www.runoob.com/wp-content/uploads/2020/09/zk11-setup.png)

双击zkCli.cmd 启动客户端

![img](https://www.runoob.com/wp-content/uploads/2020/09/zk12-setup.png)

出现 Welcome to Zookeeper！，表示我们成功启动客户端。

### 服务端集群搭建

分别修改 zoo.cfg 配置信息

zookeeper 的三个端口作用

- 1、**2181** : 对 client 端提供服务
- 2、**2888** : 集群内机器通信使用
- 3、**3888** : 选举 leader 使用

按 **server.id = ip:port:port** 修改集群配置文件:

三台虚拟机 zoo.cfg 文件末尾添加配置:

```
server.1=192.168.3.33:2888:3888
server.2=192.168.3.35:2888:3888
server.3=192.168.3.37:2888:3888
```

根据 id 和对应的地址分别配置 myid

```
vim /tmp/zookeeper/myid
```

本案例配置完成后查询显示如下：

IP 192.168.3.33 机器配置 myid，因为这台机器上个教程单机启动过，所以出现 version-2，没有也没关系。

![img](https://www.runoob.com/wp-content/uploads/2020/09/clus-05.png)

IP 192.168.3.35 机器配置 myid

![img](https://www.runoob.com/wp-content/uploads/2020/09/clus-06.png)

IP192.168.3.37 机器配置 myid

![img](https://www.runoob.com/wp-content/uploads/2020/09/clus-07.png)

启动前需要关闭防火墙(生产环境需要打开对应端口)

```
systemctl stop firewalld
```

启动 192.168.3.33 并查看日志，此时日志出现报错是正常现象，因为另外两台还没启动，暂时连接不上。

![img](https://www.runoob.com/wp-content/uploads/2020/09/clus-08.png)

另两台分别启动后，查看三台机器状态：

IP 192.168.3.33

![img](https://www.runoob.com/wp-content/uploads/2020/09/clus-09.png)

IP 192.168.3.35

![img](https://www.runoob.com/wp-content/uploads/2020/09/clus-10.png)

IP 192.168.3.37

![img](https://www.runoob.com/wp-content/uploads/2020/09/clus-11.png)

最后显示集群搭建成功！Mode：leader 代表主节点，follower 代表从节点，一主二从。

### Java 客户端

<dependency>
  <groupId>junit</groupId>
  <artifactId>junit</artifactId>
  <version>4.11</version>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.apache.zookeeper</groupId>
  <artifactId>zookeeper</artifactId>
  <version>3.4.8</version>
</dependency>
<dependency>
  <groupId>org.apache.curator</groupId>
  <artifactId>curator-framework</artifactId>
  <version>4.0.0</version>
</dependency>
<dependency>
  <groupId>org.apache.curator</groupId>
  <artifactId>curator-recipes</artifactId>
  <version>4.0.0</version>
</dependency>

#### 原生 API

    public static void main(String[] args) {
        try {
            final CountDownLatch countDownLatch=new CountDownLatch(1);
            ZooKeeper zooKeeper=
                new ZooKeeper("192.168.3.33:2181," +
                        "192.168.3.35:2181,192.168.3.37:2181",
                        4000, new Watcher() {
                    @Override
                    public void process(WatchedEvent event) {
                        if(Event.KeeperState.SyncConnected==event.getState()){
                            //如果收到了服务端的响应事件，连接成功
                            countDownLatch.countDown();
                        }
                    }
                });
            countDownLatch.await();
            //CONNECTED
            System.out.println(zooKeeper.getState());
            }
    }

#### curator

Curator 是 Netflix 公司开源的一套 zookeeper 客户端框架，解决了很多 Zookeeper 客户端非常底层的细节开发工作，包括连接重连、反复注册 Watcher 和 NodeExistsException 异常等。

Curator 包含了几个包：

- **curator-framework**：对 zookeeper 的底层 api 的一些封装。
- **curator-client**：提供一些客户端的操作，例如重试策略等。
- **curator-recipes**：封装了一些高级特性，如：Cache 事件监听、选举、分布式锁、分布式计数器、分布式 Barrier 等。

使用示例:

    public class CuratorDemo {
     
        public static void main(String[] args) throws Exception {
            CuratorFramework curatorFramework=CuratorFrameworkFactory.
                    builder().connectString("192.168.3.33:2181," +
                    "192.168.3.35:2181,192.168.3.37:2181").
                    sessionTimeoutMs(4000).retryPolicy(new
                    ExponentialBackoffRetry(1000,3)).
                    namespace("").build();
            curatorFramework.start();
            Stat stat=new Stat();
            //查询节点数据
            byte[] bytes = curatorFramework.getData().storingStatIn(stat).forPath("/runoob");
            System.out.println(new String(bytes));
            curatorFramework.close();
        }
    }

### 数据模型 znode

在 zookeeper 中，可以说 zookeeper 中的所有存储的数据是由 znode 组成的，节点也称为 znode，并以 key/value 形式存储数据。

整体结构类似于 linux 文件系统的模式以树形结构存储。其中根路径以 **/** 开头。

进入 zookeeper 安装的 bin 目录，通过sh zkCli.sh打开命令行终端，执行 "ls /" 命令显示：

```
$ ls /
$ ls /zookeeper
$ ls /zookeeper/quota
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/data-model-01.png)

我们直观的看到此时存储的数据在根目录下存在 runoob 和 zookeeper 两个节点，zookeeper 节点下存在 quota 这个节点。

![img](https://www.runoob.com/wp-content/uploads/2020/09/data-model-02.png)

### session 

客户端与服务端之间的连接是基于 TCP 长连接，client 端连接 server 端默认的 2181 端口，也就是 session 会话。

从第一次连接建立开始，客户端开始会话的生命周期，客户端向服务端的ping包请求，每个会话都可以设置一个超时时间。

Session 的状态

下面介绍几个重要的状态：

- **connecting**：连接中，session 一旦建立，状态就是 connecting 状态，时间很短。
- **connected**：已连接，连接成功之后的状态。
- **closed**：已关闭，发生在 session 过期，一般由于网络故障客户端重连失败，服务器宕机或者客户端主动断开。

### 基础命令

zookeeper 命令用于在 zookeeper 服务上执行操作。

首先执行命令，打开新的 session 会话，进入终端。

```
$ sh zkCli.sh
```

下面开始讲解基本常用命令使用，其中 acl 权限内容在后面章节详细阐述。

#### ls 命令

ls 命令用于查看某个路径下目录列表。

格式：

```
ls path
```

- **path**：代表路径。

以下实例查看 **/runoob** 节点：

```
$ ls /runoob
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/bs-command-01.png)

#### ls2 命令

ls2 命令用于查看某个路径下目录列表，它比 ls 命令列出更多的详细信息。

格式：

```
ls2 path
```

- **path**：代表路径。

以下实例查看 **/runoob** 节点：

```
$ ls2 /runoob
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/bs-command-02.png)

#### get 命令

get 命令用于获取节点数据和状态信息。

格式：

```
get path [watch]
```

- **path**：代表路径。
- **[watch]**：对节点进行事件监听。

以下实例查看同时开启两个终端。

终端一:

```
$ get /runoob watch
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/bs-command-03.png)

在终端二对此节点进行修改：

```
$ set /runoob 1
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/bs-command-04.png)

终端一自动显示 NodeDataChanged 事件：

![img](https://www.runoob.com/wp-content/uploads/2020/09/bs-command-05.png)

#### stat 命令

stat 命令用于查看节点状态信息。

格式：

```
stat path [watch]
```

- **path**：代表路径。
- **[watch]**：对节点进行事件监听。

以下实例查看 **/runoob** 节点状态：

```
$ stat /runoob
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/bs-command-06.png)

#### create 命令

create 命令用于创建节点并赋值。

格式：

```
create [-s] [-e] path data acl
```

- **[-s] [-e]**：-s 和 -e 都是可选的，-s 代表顺序节点， -e 代表临时节点，注意其中 -s 和 -e 可以同时使用的，并且临时节点不能再创建子节点。
- **path**：指定要创建节点的路径，比如 **/runoob**。
- **data**：要在此节点存储的数据。
- **path**：访问权限相关，默认是 world，相当于全世界都能访问。

以下实例添加临时顺序节点：

```
$ create -s -e /runoob 0
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/bs-command-07.png)

创建的节点既是有序，又是临时节点。

#### set 命令

set 命令用于修改节点存储的数据。

格式：

```
set path data [version]
```

- **path**：节点路径。
- **data**：需要存储的数据。
- **[version]**：可选项，版本号(可用作乐观锁)。

以下实例开启两个终端，也可以在同一终端操作：

```
$ get /runoob
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/bs-command-08.png)

下图可见，只有正确的版本号才能设置成功：

```
$ set /runoob 0 1
$ set /runoob 0 2
$ set /runoob 0 10
$ set /runoob 0 6
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/bs-command-09.png)

#### delete 命令

delete 命令用于删除某节点。

格式：

```
delete path [version]
```

- **path**：节点路径。
- **[version]**：可选项，版本号（同 set 命令）。

以下实例删除 **/runoob** 节点的子节点：

```
$ ls /runoob
$ delete /runoob/child
$ get /runoob/child
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/bs-command-10.png)

### 四字命令

zookeeper 支持某些特定的四字命令与其交互，用户获取 zookeeper 服务的当前状态及相关信息，用户在客户端可以通过 telenet 或者 nc（netcat） 向 zookeeper 提交相应的命令。

安装 nc 命令：

```
$ yum install nc                # centos
或
$ sudo apt install netcat       # ubuntu
```

四字命令格式：

```
echo [command] | nc [ip] [port]
//例
$ echo stat | nc 192.168.3.38 2181
```

ZooKeeper 常用四字命令主要如下：

| 四字命令 | 功能描述                                                     |
| :------- | ------------------------------------------------------------ |
| conf     | 3.3.0版本引入的。打印出服务相关配置的详细信息。              |
| cons     | 3.3.0版本引入的。列出所有连接到这台服务器的客户端全部连接/会话详细信息。包括"接受/发送"的包数量、会话id、操作延迟、最后的操作执行等等信息。 |
| crst     | 3.3.0版本引入的。重置所有连接的连接和会话统计信息。          |
| dump     | 列出那些比较重要的会话和临时节点。这个命令只能在leader节点上有用。 |
| envi     | 打印出服务环境的详细信息。                                   |
| reqs     | 列出未经处理的请求                                           |
| ruok     | 测试服务是否处于正确状态。如果确实如此，那么服务返回"imok"，否则不做任何相应。 |
| stat     | 输出关于性能和连接的客户端的列表。                           |
| srst     | 重置服务器的统计。                                           |
| srvr     | 3.3.0版本引入的。列出连接服务器的详细信息                    |
| wchs     | 3.3.0版本引入的。列出服务器watch的详细信息。                 |
| wchc     | 3.3.0版本引入的。通过session列出服务器watch的详细信息，它的输出是一个与watch相关的会话的列表。 |
| wchp     | 3.3.0版本引入的。通过路径列出服务器watch的详细信息。它输出一个与session相关的路径。 |
| mntr     | 3.4.0版本引入的。输出可用于检测集群健康状态的变量列表        |

### 节点特性

同一级节点 key 名称是唯一的

实例：

```
$ ls /
$ create /runoob 2
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/node-t-01.png)

已存在 **/runoob** 节点，再次创建会提示已经存在。

创建节点时，必须要带上全路径

实例：

```
$ ls /runoob
$ create /runoob/child 0
$ create /runoob/child/ch01 0
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/node-t-02.png)

session 关闭，临时节点清除

实例：

```
$ ls /runoob
$ create -e /runoob/echild 0
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/node-t-03.png)

同时终端二查看该节点:

```
$ ls /runoob
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/node-t-04.png)

**ctrl+c** 关闭终端一连接后，查询终端二 **/runoob/echild** 节点消失。

```
$ ls /runoob
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/node-t-05.png)

自动创建顺序节点

实例：

```
$ create -s -e /runoob 0
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/node-t-06.png)

watch 机制，监听节点变化

事件监听机制类似于观察者模式，watch 流程是客户端向服务端某个节点路径上注册一个 watcher，同时客户端也会存储特定的 watcher，当节点数据或子节点发生变化时，服务端通知客户端，客户端进行回调处理。特别注意：监听事件被单次触发后，事件就失效了。

**提示：**参考常用命令章节 get 命令监听 watch 使用，后面章节将详细介绍 watch 实现原理。

delete 命令只能一层一层删除

实例：

```
$ ls /
$ delete /runoob
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/node-t-07.png)

※新版本可以通过 **deleteall** 命令递归删除。

### 权限控制 ACL

ACL 权限可以针对节点设置相关读写等权限，保障数据安全性。

permissions 可以指定不同的权限范围及角色。

#### ACL 命令行

- **getAcl 命令**：获取某个节点的 acl 权限信息。
- **setAcl 命令**：设置某个节点的 acl 权限信息。
- **addauth 命令**：输入认证授权信息，注册时输入明文密码，加密形式保存。

#### ACL 构成

zookeeper 的 acl 通过 **[**scheme:id:permissions**]** 来构成权限列表。

- 1、**scheme**：代表采用的某种权限机制，包括 world、auth、digest、ip、super 几种。
- 2、**id**：代表允许访问的用户。
- 3、**permissions**：权限组合字符串，由 cdrwa 组成，其中每个字母代表支持不同权限， 创建权限 create(c)、删除权限 delete(d)、读权限 read(r)、写权限 write(w)、管理权限admin(a)。

#### world 实例

查看默认节点权限，再更新节点 permissions 权限部分为 crwa，结果删除节点失败。其中 world 代表开放式权限。

```
$ getAcl /runoob/child
$ setAcl /runoob/child world:anyone:crwa
$ delete /runoob/child
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/zk-acl-01.png)

#### auth 实例

auth 用于授予权限，注意需要先创建用户。

```
$ setAcl /runoob/child auth:user1:123456:cdrwa
$ addauth digest user1:123456
$ setAcl /runoob/child auth:user1:123456:cdrwa
$ getAcl /runoob/child
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/zk-acl-02.png)

#### digest 实例

退出当前用户，重新连接终端，digest 可用于账号密码登录和验证。。

```
$ ls /runoob
$ create /runoob/child01 runoob
$ getAcl /runoob/child01
$ setAcl /runoob/child01 digest:user1:HYGa7IZRm2PUBFiFFu8xY2pPP/s=:cdra
$ getAcl /runoob/child01
$ addauth digest user1:123456
$ getAcl /runoob/child01
```

**提示：**加密密码是上一步创建的。

![img](https://www.runoob.com/wp-content/uploads/2020/09/zk-acl-03.png)

#### IP 实例

限制 IP 地址的访问权限，把权限设置给 IP 地址为 192.168.3.7 后，IP 为 192.168.3.38 已经没有访问权限。

```
$ create /runoob/ip 0
$ getAcl /runoob/ip
$ setAcl /runoob/ip ip:192.168.3.7:cdrwa
$ get /runoob/ip
```

![img](https://www.runoob.com/wp-content/uploads/2020/09/zk-acl-04.png)

### watcher 事件

zookeeper 的 watcher 机制，可以分为四个过程：

- 客户端注册 watcher。
- 服务端处理 watcher。
- 服务端触发 watcher 事件。
- 客户端回调 watcher。

其中客户端注册 watcher 有三种方式，调用客户端 API 可以分别通过 getData、exists、getChildren 实现，利用前面章节创建的 maven 工程，新建 WatcherDemo 类，以 exists 方法举例说明其原理。

**public** **class** WatcherDemo **implements** Watcher {
  **static** ZooKeeper zooKeeper;
  **static** {
    **try** {
      zooKeeper = **new** ZooKeeper("192.168.3.39:2181", 4000,**new** WatcherDemo());
    } **catch** (IOException e) {
      e.printStackTrace();
    }
  }
  @Override
  **public** **void** process(WatchedEvent event) {
    System.out.println("eventType:"+event.getType());
    **if**(event.getType()==Event.EventType.NodeDataChanged){
      **try** {
        zooKeeper.exists(event.getPath(),**true**);
      } **catch** (KeeperException e) {
        e.printStackTrace();
      } **catch** (InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
  **public** **static** **void** main(String[] args) **throws** IOException, KeeperException, InterruptedException {
    String path="/watcher";
    **if**(zooKeeper.exists(path,**false**)==**null**) {
      zooKeeper.create("/watcher", "0".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
    }
    Thread.sleep(1000);
    System.out.println("-----------");
    *//true表示使用zookeeper实例中配置的watcher*
    Stat stat=zooKeeper.exists(path,**true**);
    System.in.read();
  }
}

###  数据同步

 Zookeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性。

ZAB 协议分为两部分：

- 消息广播
- 崩溃恢复

#### 消息广播

Zookeeper 使用单一的主进程 Leader 来接收和处理客户端所有事务请求，并采用 ZAB 协议的原子广播协议，将事务请求以 Proposal 提议广播到所有 Follower 节点，当集群中有过半的Follower 服务器进行正确的 ACK 反馈，那么Leader就会再次向所有的 Follower 服务器发送commit 消息，将此次提案进行提交。这个过程可以简称为 2pc 事务提交，整个流程可以参考下图，注意 Observer 节点只负责同步 Leader 数据，不参与 2PC 数据同步过程。

![img](https://www.runoob.com/wp-content/uploads/2020/09/zk-data-stream-async.png)

#### 崩溃恢复

在正常情况消息广播情况下能运行良好，但是一旦 Leader 服务器出现崩溃，或者由于网络原理导致 Leader 服务器失去了与过半 Follower 的通信，那么就会进入崩溃恢复模式，需要选举出一个新的 Leader 服务器。在这个过程中可能会出现两种数据不一致性的隐患，需要 ZAB 协议的特性进行避免。

- 1、Leader 服务器将消息 commit 发出后，立即崩溃
- 2、Leader 服务器刚提出 proposal 后，立即崩溃

ZAB 协议的恢复模式使用了以下策略：

- 1、选举 zxid 最大的节点作为新的 leader
- 2、新 leader 将事务日志中尚未提交的消息进行处理

※致使ZooKeeper节点状态改变的每一个操作都将使节点接收到一个Zxid格式的时间戳，并且这个时间戳**全局有序**。也就是说，每个对节点的改变都将产生一个唯一的Zxid。如果Zxid1的值小于Zxid2的值，那么Zxid1所对应的事件发生在Zxid2所对应的事件之前。实际上，ZooKeeper的每个节点维护者两个Zxid值，为别为：cZxid、mZxid。

（1）cZxid： 是节点的创建时间所对应的Zxid格式时间戳。

（2）mZxid：是节点的修改时间所对应的Zxid格式时间戳。

实现中Zxid是一个64为的数字，它高32位是epoch用来标识Leader关系是否改变，每次一个Leader被选出来，它都会有一个新的epoch。低32位是个递增计数。

### Leader 选举

zookeeper 的 leader 选举存在两个阶段，一个是服务器启动时 leader 选举，另一个是运行过程中 leader 服务器宕机。在分析选举原理前，先介绍几个重要的参数。

- 服务器 ID(myid)：编号越大在选举算法中权重越大
- 事务 ID(zxid)：值越大说明数据越新，权重越大
- 逻辑时钟(epoch-logicalclock)：同一轮投票过程中的逻辑时钟值是相同的，每投完一次值会增加

**选举状态：**

- **LOOKING**: 竞选状态
- **FOLLOWING**: 随从状态，同步 leader 状态，参与投票
- **OBSERVING**: 观察状态，同步 leader 状态，不参与投票
- **LEADING**: 领导者状态

#### 服务器启动时的 leader 选举

每个节点启动的时候都 LOOKING 观望状态，接下来就开始进行选举主流程。这里选取三台机器组成的集群为例。第一台服务器 server1启动时，无法进行 leader 选举，当第二台服务器 server2 启动时，两台机器可以相互通信，进入 leader 选举过程。

- （1）每台 server 发出一个投票，由于是初始情况，server1 和 server2 都将自己作为 leader 服务器进行投票，每次投票包含所推举的服务器myid、zxid、epoch，使用（myid，zxid）表示，此时 server1 投票为（1,0），server2 投票为（2,0），然后将各自投票发送给集群中其他机器。
- （2）接收来自各个服务器的投票。集群中的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票（epoch）、是否来自 LOOKING 状态的服务器。
- （3）分别处理投票。针对每一次投票，服务器都需要将其他服务器的投票和自己的投票进行对比，对比规则如下：
  - a. 优先比较 epoch
  - b. 检查 zxid，zxid 比较大的服务器优先作为 leader
  - c. 如果 zxid 相同，那么就比较 myid，myid 较大的服务器作为 leader 服务器
- （4）统计投票。每次投票后，服务器统计投票信息，判断是都有过半机器接收到相同的投票信息。server1、server2 都统计出集群中有两台机器接受了（2,0）的投票信息，此时已经选出了 server2 为 leader 节点。
- （5）改变服务器状态。一旦确定了 leader，每个服务器响应更新自己的状态，如果是 follower，那么就变更为 FOLLOWING，如果是 Leader，变更为 LEADING。此时 server3继续启动，直接加入变更自己为 FOLLOWING。

![img](https://www.runoob.com/wp-content/uploads/2020/09/vote-01.png)

#### 运行过程中的 leader 选举

当集群中 leader 服务器出现宕机或者不可用情况时，整个集群无法对外提供服务，进入新一轮的 leader 选举。

- （1）变更状态。leader 挂后，其他非 Observer服务器将自身服务器状态变更为 LOOKING。
- （2）每个 server 发出一个投票。在运行期间，每个服务器上 zxid 可能不同。
- （3）处理投票。规则同启动过程。
- （4）统计投票。与启动过程相同。
- （5）改变服务器状态。与启动过程相同。

### 分布式锁

curator 的几种锁方案 ：

- 1、**InterProcessMutex**：分布式可重入排它锁
- 2、**InterProcessSemaphoreMutex**：分布式排它锁
- 3、**InterProcessReadWriteLock**：分布式读写锁

下面例子模拟 50 个线程使用重入排它锁 InterProcessMutex 同时争抢锁：

实例

**public** **class** InterprocessLock {
  **public** **static** **void** main(String[] args) {
    CuratorFramework zkClient = getZkClient();
    String lockPath = "/lock";
    InterProcessMutex lock = **new** InterProcessMutex(zkClient, lockPath);
    *//模拟50个线程抢锁*
    **for** (**int** i = 0; i < 50; i++) {
      **new** Thread(**new** TestThread(i, lock)).start();
    }
  }


  **static** **class** TestThread **implements** Runnable {
    **private** Integer threadFlag;
    **private** InterProcessMutex lock;

​    **public** TestThread(Integer threadFlag, InterProcessMutex lock) {
​      **this**.threadFlag = threadFlag;
​      **this**.lock = lock;
​    }

​    @Override
​    **public** **void** run() {
​      **try** {
​        lock.acquire();
​        System.out.println("第"+threadFlag+"线程获取到了锁");
​        *//等到1秒后释放锁*
​        Thread.sleep(1000);
​      } **catch** (Exception e) {
​        e.printStackTrace();
​      }**finally** {
​        **try** {
​          lock.release();
​        } **catch** (Exception e) {
​          e.printStackTrace();
​        }
​      }
​    }
  }

  **private** **static** CuratorFramework getZkClient() {
    String zkServerAddress = "192.168.3.39:2181";
    ExponentialBackoffRetry retryPolicy = **new** ExponentialBackoffRetry(1000, 3, 5000);
    CuratorFramework zkClient = CuratorFrameworkFactory.builder()
        .connectString(zkServerAddress)
        .sessionTimeoutMs(5000)
        .connectionTimeoutMs(5000)
        .retryPolicy(retryPolicy)
        .build();
    zkClient.start();
    **return** zkClient;
  }
}

## Dubbo

[Apache Dubbo](http://dubbo.apache.org/zh/)

[Dubbo 一篇文章就够了：从入门到实战 - SegmentFault 思否](https://segmentfault.com/a/1190000019896723)

[Dubbo - 简书 (jianshu.com)](https://www.jianshu.com/p/3090d63e9cb3)

Apache Dubbo 是一款高性能、轻量级的开源 Java 服务框架

提供了六大核心能力：面向接口代理的高性能RPC调用，智能容错和负载均衡，服务自动注册和发现，高度可扩展能力，运行期流量调度，可视化的服务治理与运维。

![摘录于官网](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81ODI0MDE2LWVlYWMzNDRhYzcwZmRlZDUuanBn)

### 技术架构

![摘自官网](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81ODI0MDE2LWU1OTliNDA0NjZlODRjNmIuanBn)

**节点角色说明**

| 节点      | 角色说明                               |
| --------- | -------------------------------------- |
| Provider  | 暴露服务的服务提供方                   |
| Consumer  | 调用远程服务的服务消费方               |
| Registry  | 服务注册与发现的注册中心               |
| Monitor   | 统计服务的调用次数和调用时间的监控中心 |
| Container | 服务运行容器                           |

- 启动容器，加载，**运行服务提供者**。
- 服务提供者在启动时，在注册中心**发布注册**自己提供的**服务**。
- 服务消费者在启动时，在注册中心**订阅**自己所需的**服务**。

如果考虑**失败或变更**的情况，就需要考虑下面的过程。

- 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
- 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
- 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

### 服务端

#### 导入 maven 依赖

```
    <dependencies>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>dubbo</artifactId>
            <version>2.6.6</version>
        </dependency>
        <dependency>
            <groupId>org.apache.zookeeper</groupId>
            <artifactId>zookeeper</artifactId>
            <version>3.4.10</version>
        </dependency>
        <dependency>
            <groupId>com.101tec</groupId>
            <artifactId>zkclient</artifactId>
            <version>0.5</version>
        </dependency>
        <dependency>
            <groupId>io.netty</groupId>
            <artifactId>netty-all</artifactId>
            <version>4.1.32.Final</version>
        </dependency>
        <dependency>
            <groupId>org.apache.curator</groupId>
            <artifactId>curator-framework</artifactId>
            <version>2.8.0</version>
        </dependency>
        <dependency>
            <groupId>org.apache.curator</groupId>
            <artifactId>curator-recipes</artifactId>
            <version>2.8.0</version>
        </dependency>
    </dependencies>
```

#### **配置provider.xml** 

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
       xsi:schemaLocation="http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd">

    <!--当前项目在整个分布式架构里面的唯一名称，计算依赖关系的标签-->
    <dubbo:application name="provider" owner="sihai">
        <dubbo:parameter key="qos.enable" value="true"/>
        <dubbo:parameter key="qos.accept.foreign.ip" value="false"/>
        <dubbo:parameter key="qos.port" value="55555"/>
    </dubbo:application>

    <dubbo:monitor protocol="registry"/>

    <!--dubbo这个服务所要暴露的服务地址所对应的注册中心-->
    <!--<dubbo:registry address="N/A"/>-->
    <dubbo:registry address="N/A" />

    <!--当前服务发布所依赖的协议；webserovice、Thrift、Hessain、http-->
    <dubbo:protocol name="dubbo" port="20880"/>

    <!--服务发布的配置，需要暴露的服务接口-->
    <dubbo:service
            interface="com.sihai.dubbo.provider.service.ProviderService"
            ref="providerService"/>

    <!--Bean bean定义-->
    <bean id="providerService" class="com.sihai.dubbo.provider.service.ProviderServiceImpl"/>

</beans>
```

#### 发布接口

```
        //加载xml配置文件启动
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("provider.xml");
        context.start();
        System.in.read(); // 按任意键退出
    }
```

### 消费端

#### 配置consumer.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
       xsi:schemaLocation="http://www.springframework.org/schema/beans            
       http://www.springframework.org/schema/beans/spring-beans.xsd        
       http://code.alibabatech.com/schema/dubbo        
       http://code.alibabatech.com/schema/dubbo/dubbo.xsd">

    <!--当前项目在整个分布式架构里面的唯一名称，计算依赖关系的标签-->
    <dubbo:application name="consumer" owner="sihai"/>

    <!--dubbo这个服务所要暴露的服务地址所对应的注册中心-->
    <!--点对点的方式-->
    <dubbo:registry address="N/A" />
    <!--<dubbo:registry address="zookeeper://localhost:2181" check="false"/>-->

    <!--生成一个远程服务的调用代理-->
    <!--点对点方式-->
    <dubbo:reference id="providerService"
                     interface="com.sihai.dubbo.provider.service.ProviderService"
                     url="dubbo://192.168.234.1:20880/com.sihai.dubbo.provider.service.ProviderService"/>
    <!--<dubbo:reference id="providerService"
                     interface="com.sihai.dubbo.provider.service.ProviderService"/>-->
</beans>
```

#### 调用服务

```
        ClassPathXmlApplicationContext context=new ClassPathXmlApplicationContext("consumer.xml");
        context.start();
        ProviderService providerService = (ProviderService) context.getBean("providerService");
        String str = providerService.SayHello("hello");
        System.out.println(str);
        System.in.read();
    }
```

### 注册中心

很多时候都是使用 dubbo + zookeeper 的方式，使用 zookeeper 作为注册中心.

#### 服务端

```
<dubbo:registry address="zookeeper://localhost:2181" />
or
<dubbo:registry protocol="zookeeper" address="192.168.11.129:2181,192.168.11.137:2181,192.168.11.138:2181"/>
```

####  消费端

```
<dubbo:registry address="zookeeper://localhost:2181"/>
or
<dubbo:reference id="providerService" interface="com.sihai.dubbo.provider.service.ProviderService"/>
```

### 其他配置方式

#### API配置

##### 服务端

```
  // 服务实现
        ProviderService providerService = new ProviderServiceImpl();

        // 当前应用配置
        ApplicationConfig application = new ApplicationConfig();
        application.setName("provider");
        application.setOwner("sihai");

        // 连接注册中心配置
        RegistryConfig registry = new RegistryConfig();
        registry.setAddress("zookeeper://localhost:2181");
//        registry.setUsername("aaa");
//        registry.setPassword("bbb");

        // 服务提供者协议配置
        ProtocolConfig protocol = new ProtocolConfig();
        protocol.setName("dubbo");
        protocol.setPort(20880);
        //protocol.setThreads(200);

        // 注意：ServiceConfig为重对象，内部封装了与注册中心的连接，以及开启服务端口

        // 服务提供者暴露服务配置
        ServiceConfig<ProviderService> service = new ServiceConfig<ProviderService>(); // 此实例很重，封装了与注册中心的连接，请自行缓存，否则可能造成内存和连接泄漏
        service.setApplication(application);
        service.setRegistry(registry); // 多个注册中心可以用setRegistries()
        service.setProtocol(protocol); // 多个协议可以用setProtocols()
        service.setInterface(ProviderService.class);
        service.setRef(providerService);
        service.setVersion("1.0.0");

        // 暴露及注册服务
        service.export();
```

##### 消费端

```
  // 当前应用配置
        ApplicationConfig application = new ApplicationConfig();
        application.setName("consumer");
        application.setOwner("sihai");

        // 连接注册中心配置
        RegistryConfig registry = new RegistryConfig();
        registry.setAddress("zookeeper://localhost:2181");

        // 注意：ReferenceConfig为重对象，内部封装了与注册中心的连接，以及与服务提供方的连接

        // 引用远程服务
        ReferenceConfig<ProviderService> reference = new ReferenceConfig<ProviderService>(); // 此实例很重，封装了与注册中心的连接以及与提供者的连接，请自行缓存，否则可能造成内存和连接泄漏
        reference.setApplication(application);
        reference.setRegistry(registry); // 多个注册中心可以用setRegistries()
        reference.setInterface(ProviderService.class);

        // 和本地bean一样使用xxxService
        ProviderService providerService = reference.get(); // 注意：此代理对象内部封装了所有通讯细节，对象较重，请缓存复用
        providerService.SayHello("hello dubbo! I am sihai!");
    }
```

#### 注解配置

```
/**
 * 注解方式配置
 */
@Configuration
@EnableDubbo(scanBasePackages = "com.sihai.dubbo.provider.service.annotation")
public class DubboConfiguration {

    @Bean // #1 服务提供者信息配置
    public ProviderConfig providerConfig() {
        ProviderConfig providerConfig = new ProviderConfig();
        providerConfig.setTimeout(1000);
        return providerConfig;
    }

    @Bean // #2 分布式应用信息配置
    public ApplicationConfig applicationConfig() {
        ApplicationConfig applicationConfig = new ApplicationConfig();
        applicationConfig.setName("dubbo-annotation-provider");
        return applicationConfig;
    }

    @Bean // #3 注册中心信息配置
    public RegistryConfig registryConfig() {
        RegistryConfig registryConfig = new RegistryConfig();
        registryConfig.setProtocol("zookeeper");
        registryConfig.setAddress("localhost");
        registryConfig.setPort(2181);
        return registryConfig;
    }

    @Bean // #4 使用协议配置，这里使用 dubbo
    public ProtocolConfig protocolConfig() {
        ProtocolConfig protocolConfig = new ProtocolConfig();
        protocolConfig.setName("dubbo");
        protocolConfig.setPort(20880);
        return protocolConfig;
    }
}

//启动服务
AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DubboConfiguration.class); 
        context.start();
        System.in.read(); 
```

## Spring Cloud

[Spring Cloud](https://spring.io/projects/spring-cloud/)

[Spring Cloud Greenwich 中文文档 参考手册 中文版](https://www.springcloud.cc/spring-cloud-greenwich.html)

[Spring Cloud 入门总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/95696180?from_voters_page=true)

[SpringCloud gateway （史上最全） - 疯狂创客圈 - 博客园 (cnblogs.com)](https://www.cnblogs.com/crazymakercircle/p/11704077.html)

[Spring Cloud 系列之 Spring Cloud Stream - 风的姿态 - 博客园 (cnblogs.com)](https://www.cnblogs.com/fengzheng/p/11576661.html)

[SpringCloudStream最全教程,包括配置文件描述_晴天小哥哥的博客-CSDN博客](https://blog.csdn.net/weixin_38399962/article/details/82192340)

构建分布式系统不需要复杂和容易出错。Spring Cloud 为最常见的分布式系统模式提供了一种简单且易于接受的编程模型，帮助开发人员构建有弹性的、可靠的、协调的应用程序。Spring Cloud 构建于 Spring Boot 之上，使得开发者很容易入手并快速应用于生产中。

就是微服务系统架构的一站式解决方案，在平时我们构建微服务的过程中需要做如 **服务发现注册** 、**配置中心** 、**消息总线** 、**负载均衡** 、**断路器** 、**数据监控** 等操作，而 Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。

![preview](https://pic2.zhimg.com/v2-25915a395592b4a88a3a35dff89ab969_r.jpg)

### Eureka

**服务发现**：中介

Eureka是基于REST（代表性状态转移）的服务，主要在AWS云中用于定位服务，以实现负载均衡和中间层服务器的故障转移。我们称此服务为Eureka服务器。Eureka还带有一个基于Java的客户端组件Eureka Client，它使与服务的交互变得更加容易。客户端还具有一个内置的负载平衡器，可以执行基本的循环负载平衡。在Netflix，更复杂的负载均衡器将Eureka包装起来，以基于流量，资源使用，错误条件等多种因素提供加权负载均衡，以提供出色的弹性。

![img](https://pic2.zhimg.com/80/v2-f032bf5d72f5a14d348a4993992a677d_720w.jpg)

### Ribbon

负载均衡

`Ribbon` 是运行在消费者端的负载均衡器

### Hystrix

> 在分布式环境中，不可避免地会有许多服务依赖项中的某些失败。Hystrix是一个库，可通过添加等待时间容限和容错逻辑来帮助您控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点，停止服务之间的级联故障并提供后备选项来实现此目的，所有这些都可以提高系统的整体弹性。

总体来说 `Hystrix` 就是一个能进行 **熔断** 和 **降级** 的库，通过使用它能提高整个系统的弹性。

### Config

> `Spring Cloud Config` 为分布式系统中的外部化配置提供服务器和客户端支持。使用 `Config` 服务器，可以在中心位置管理所有环境中应用程序的外部属性。

简单来说，`Spring Cloud Config` 就是能将各个 应用/系统/模块 的配置文件存放到 **统一的地方然后进行管理**(Git 或者 SVN)。

### Open Feign

OpenFeign 也是运行在消费者端的，使用 Ribbon 进行负载均衡，所以 OpenFeign 直接内置了 Ribbon。

```java
// 使用 @FeignClient 注解来指定提供者的名字
@FeignClient(value = "eureka-client-provider")
public interface TestClient {
    // 这里一定要注意需要使用的是提供者那端的请求相对路径，这里就相当于映射了
    @RequestMapping(value = "/provider/xxx",
    method = RequestMethod.POST)
    CommonResponse<List<Plan>> getPlans(@RequestBody planGetRequest request);
}
```

### Gateway 

pringCloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。

SpringCloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 2.0之前的非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。

Spring Cloud Gateway 的目标，不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。

### Spring Cloud Stream 

Spring Cloud Stream 是消息中间件组件，它集成了 kafka 和 rabbitmq 

## Spring cloud Alibaba

[Spring Cloud Alibaba](https://spring.io/projects/spring-cloud-alibaba)

[Spring cloud Alibaba 从入门到放弃 - hello靓仔 - 博客园 (cnblogs.com)](https://www.cnblogs.com/lihaipengjava/p/12025242.html)

spring cloud中的几乎所有的组件都使用Netflix公司的产品，然后在其基础上做了一层封装。然而Netflix的服务发现组件Eureka已经停止更新，我们公司在使用的时候就发现过其一个细小的Bug；而其他的众多组件预计会在明年(即2020年)停止维护。所以急需其他的一些替代产品，也就是spring cloud alibaba，目前正处于蓬勃发展的态式。

## 分布式服务管理

### 服务削峰

使用一些技术手段，来削弱瞬时的请求高峰，让系统吞吐量在高峰请求下保持可控。

### 服务降级

降级就是为了解决资源不足和访问量增加的矛盾

在有限的资源情况下，为了能抗住大量的请求，就需要对系统做出一些牺牲，有点“弃卒保帅”的意思。放弃一些功能，保证整个系统能平稳运行

### 服务熔断

熔断模式可以防止应用程序不断地尝试可能超时和失败的服务，能达到应用程序执行而不必等待下游服务修正错误服务。

### 服务限流

通过对并发访问进行限速。

## 分布式框架调用问题

### 跨域问题

跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。

**解决方案**

1.使用jsonp跨域请求

2.使用@crossorigin

3.使用httpclient的API,进行跨域请求

### HttpClient

实现了所有 HTTP 的方法（GET、POST、PUT、HEAD、DELETE、HEAD、OPTIONS 等）
支持 HTTPS 协议
支持代理服务器（Nginx等）等
支持自动（跳转）转向

**示例**

```java
 private static final CloseableHttpClient httpclient = HttpClients.createDefault();
 HttpGet httpget = new HttpGet(url);
 CloseableHttpResponse response = httpclient.execute(httpget);

 String result = null;
 HttpEntity entity = response.getEntity();
 if (entity != null) {
     result = EntityUtils.toString(entity);
 }
 System.out.println(result);
```

### RestTemplate

是 Spring 提供的用于访问 Rest 服务的客户端，RestTemplate 提供了多种便捷访问远程Http服务的方法，能够大大提高客户端的编写效率，所以很多客户端比如 Android或者第三方服务商都是使用 RestTemplate 请求 restful 服务。

**示例**

```java
@Autowired  
private RestTemplate restTemplate;  

String result = restTemplate.getForObject(url, String.class);
System.out.println(result);
```