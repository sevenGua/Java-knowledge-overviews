# 底层调优与算法深入

## 数据结构与算法 高级数据结构

### 数组

数组（Array）是有序的元素序列。若将有限个类型相同的变量的[集合](https://baike.baidu.com/item/集合/2908117)命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为[下标变量](https://baike.baidu.com/item/下标变量/12713827)。用于区分数组的各个元素的数字编号称为下标。数组是在[程序设计](https://baike.baidu.com/item/程序设计/223952)中，为了处理方便， 把具有相同类型的若干元素按有序的形式组织起来的一种形式。 这些有序排列的同类数据元素的集合称为数组。

数组是用于储存多个相同类型数据的集合。

### 链表

链表是一种物理[存储单元](https://baike.baidu.com/item/存储单元/8727749)上非连续、非顺序的[存储结构](https://baike.baidu.com/item/存储结构/350782)，[数据元素](https://baike.baidu.com/item/数据元素/715313)的逻辑顺序是通过链表中的[指针](https://baike.baidu.com/item/指针/2878304)链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储[数据元素](https://baike.baidu.com/item/数据元素)的数据域，另一个是存储下一个结点地址的[指针](https://baike.baidu.com/item/指针/2878304)域。 相比于[线性表](https://baike.baidu.com/item/线性表/3228081)[顺序结构](https://baike.baidu.com/item/顺序结构/9845234)，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。

![在这里插入图片描述](https://img-blog.csdn.net/20180928135003419?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RlZF9jcw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### 单向链表

单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针，下图就是一个单链表，表头为空，表头的后继节点是"结点10"(数据为10的结点)，"节点10"的后继结点是"节点20"(数据为10的结点)。

![img](https://pic4.zhimg.com/80/v2-392a58393fd03c2893bfb21b3a7b0d97_720w.jpg)

#### 双向链表

双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。

双链表的示意图如下：

![img](https://pic3.zhimg.com/80/v2-2ee9141bae02c577c1143fe42bad1456_720w.jpg)

表头为空，表头的后继节点为"节点10"(数据为10的节点)；"节点10"的后继节点是"节点20"(数据为10的节点)，"节点20"的前继节点是"节点10"；"节点20"的后继节点是"节点30"，"节点30"的前继节点是"节点20"；...；末尾节点的后继节点是表头。

不难看出，双向链表的节点定义可以用一个下面的结构体表示：

```cpp
//双向链表节点结构
typedef struct dlink_node
{
    struct dlink_node *prev;
    struct dlink_node *next;
    void *val;  //能存储任意类型数据
}node;
```

### 队列

队列是一种特殊的[线性表](https://baike.baidu.com/item/线性表/3228081)，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。

队列中的数据元素遵循“先进先出”（First In First Out）的原则，简称FIFO结构。

### 栈

栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

栈中的数据元素遵循“先进先出”（First In First Out）的原则，简称FIFO结构。

### 树

**树**是一种[数据结构](https://baike.baidu.com/item/数据结构/1450)，它是由*n(n>=1*)个有限结点组成一个具有层次关系的[集合](https://baike.baidu.com/item/集合/2908117)。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

每个结点有零个或多个子结点；没有[父结点](https://baike.baidu.com/item/父结点/9796346)的结点称为[根结点](https://baike.baidu.com/item/根结点/9795570)；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树；

![img](https://bkimg.cdn.bcebos.com/pic/6159252dd42a2834218a2c2154b5c9ea15cebfef?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5)

### 图

 图（Graph）结构是一种非线性的数据结构，图在实际生活中有很多例子，比如交通运输网，地铁网络，社交网络，计算机中的状态执行（自动机）等等都可以抽象成图结构。图结构比树结构复杂的非线性结构。

**1.顶点（vertex）：**图中的数据元素，如图一。

**2.边（edge）：**图中连接这些顶点的线，如图一。

**![img](https://images2018.cnblogs.com/blog/824470/201805/824470-20180529213912198-1480738951.png)**

### 堆

堆通常是一个可以被看做一棵[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232)的数组对象。

### 排序

[十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)](https://www.cnblogs.com/onepixel/articles/7674659.html)

所谓排序，就是使一串[记录](https://baike.baidu.com/item/记录/1837758)，按照其中的某个或某些[关键字](https://baike.baidu.com/item/关键字/7105697)的大小，递增或递减的排列起来的[操作](https://baike.baidu.com/item/操作/5797370)。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域中考虑到数据的各种限制和规范，要得到一个符合实际的优秀算法，得经过大量的推理和分析。

(1)冒泡排序；

(2)选择排序；

(3)插入排序；

(4)希尔排序；

(5)归并排序；

(6)快速排序；

(7)基数排序；

(8)堆排序；

(9)计数排序；

(10)桶排序。

![img](https://img2018.cnblogs.com/blog/849589/201903/849589-20190306165258970-1789860540.png)

![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)

### 递归

**递归算法**（英语：recursion algorithm）在[计算机科学](https://baike.baidu.com/item/计算机科学/9132)中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。递归式方法可以被用于解决很多的计算机科学问题，因此它是计算机科学中十分重要的一个概念。绝大多数[编程语言](https://baike.baidu.com/item/编程语言/9845131)支持[函数](https://baike.baidu.com/item/函数/301912)的自调用，在这些语言中函数可以通过调用自身来进行递归。[计算理论](https://baike.baidu.com/item/计算理论/3729830)可以证明递归的作用可以完全取代[循环](https://baike.baidu.com/item/循环)，因此在很多[函数编程语言](https://baike.baidu.com/item/函数编程语言)（如[Scheme](https://baike.baidu.com/item/Scheme)）中习惯用递归来实现循环。

**1). 明确递归终止条件**

　　 我们知道，递归就是有去有回，既然这样，那么必然应该有一个明确的临界点，程序一旦到达了这个临界点，就不用继续往下递去而是开始实实在在的归来。换句话说，该临界点就是一种简单情境，可以防止无限递归。

**2). 给出递归终止时的处理办法**

　　 我们刚刚说到，在递归的临界点存在一种简单情境，在这种简单情境下，我们应该直接给出问题的解决方案。一般地，在这种情境下，问题的解决方案是直观的、容易的。

**3). 提取重复的逻辑，缩小问题规模**

　　 我们在阐述递归思想内涵时谈到，递归问题必须可以分解为若干个规模较小、与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决。从程序实现的角度而言，我们需要抽象出一个干净利落的重复的逻辑，以便使用相同的方式解决子问题。

### 回溯

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优[搜索](https://baike.baidu.com/item/搜索/2791632)法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

### 深度与广度优先搜索

#### 深度优先搜索（DFS）

 深度优先搜索属于图算法的一种，是一个针对图和树的遍历算法，英文缩写为DFS即Depth First Search。深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现DFS算法。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。

#### 广度优先搜索（BFS）

  广度优先搜索（也称宽度优先搜索，缩写BFS，以下采用广度来描述）是连通图的一种遍历算法这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。基本过程，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。一般用队列数据结构来辅助实现BFS算法。

### 动态规划

能采用动态规划求解的问题的一般要具有3个性质：

  (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。

  (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。

  （3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）

### 二分搜索

二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。

### 贪婪算法

**贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法。**

**贪婪算法所得到的结果往往不是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果。**

- 贪婪算法并**没有固定的算法解决框架**，算法的关键是贪婪策略的选择，根据不同的问题选择不同的策略。
- 必须注意的是策略的选择必须具备无后效性，即某个状态的选择不会影响到之前的状态，只与当前状态有关，所以对采用的贪婪的策略一定要仔细分析其是否满足无后效性。

## 高并发编程核心

### 线程的6种状态与状态流转

[Java：线程的六种状态及转化 - 天乔巴夏丶 - 博客园 (cnblogs.com)](https://www.cnblogs.com/summerday152/p/12288671.html)

![img](https://img2018.cnblogs.com/blog/1771072/202002/1771072-20200209204908012-1070559737.png)

#### 新建状态(NEW)

即用**new关键字**新建一个线程，这个线程就处于**新建状态**。

#### 运行状态(RUNNABLE)

操作系统中的就绪和运行两种状态，在Java中统称为RUNNABLE。

##### 就绪状态（READY)

当线程对象调用了`start()`方法之后，线程处于**就绪状态**，就绪意味着该线程**可以执行**，但具体啥时候执行将取决于JVM里线程调度器的调度。

- 不允许对一个线程多次使用start。
- 线程执行完成之后，不能试图用start将其唤醒。

###### 其他状态 ->就绪

- 线程调用start()，新建状态转化为就绪状态。
- 线程sleep(long)时间到，等待状态转化为就绪状态。
- 阻塞式IO操作结果返回，线程变为就绪状态。
- 其他线程调用join()方法，结束之后转化为就绪状态。
- 线程对象拿到对象锁之后，也会进入就绪状态。

##### 运行状态(RUNNING)

处于就绪状态的线程获得了CPU之后，真正开始执行run()方法的线程执行体时，意味着该线程就已经处于运行状态。需要注意的是，对于单处理器，一个时刻只能有一个线程处于运行状态。
对于抢占式策略的系统来说，系统会给每个线程一小段时间处理各自的任务。时间用完之后，系统负责夺回线程占用的资源。下一段时间里，系统会根据一定规则，再次进行调度。

**运行状态转变为就绪状态的情形**

- 线程失去处理器资源。线程不一定完整执行的，执行到一半，说不定就被别的线程抢走了。
- 调用yield()静态方法，暂时暂停当前线程，让系统的线程调度器重新调度一次，它自己完全有可能再次运行。

提示调度程序，当前线程愿意放弃当前对处理器的使用。这时，当前线程将会被置为就绪状态，和其他线程一样等待调度，这时候根据不同优先级决定的概率，当前线程完全有可能再次抢到处理器资源。

##### 阻塞状态(BLOCKED)

阻塞状态表示线程正等待监视器锁，而陷入的状态。

以下场景线程将会阻塞：

- 线程等待进入synchronized同步方法。
- 线程等待进入synchronized同步代码块。

线程取得锁，就会从阻塞状态转变为就绪状态。

##### 等待状态(WAITING)

进入该状态表示当前线程需要等待其他线程做出一些的特定的动作（通知或中断）。

###### 运行->等待

- 当前线程运行过程中，其他线程调用`join`方法，当前线程将会进入等待状态。
- 当前线程对象调用`wait()`方法。
  -`LockSupport.park()`：出于线程调度的目的**禁用当前线程**。

###### 等待->就绪

- 等待的线程被其他线程对象唤醒，`notify()`和`notifyAll()`。
- `LockSupport.unpark(Thread)`，与上面park方法对应，给出许可证，解除等待状态。

##### 超时等待状态(TIMED_WAITING)

区别于`WAITING`，它可以在**指定的时间**自行返回。

###### 运行->超时等待

- 调用静态方法，`Thread.sleep(long)`
- 线程对象调用`wait(long)`方法
- 其他线程调用指定时间的`join(long)`。
- `LockSupport.parkNanos()`。
- `LockSupport.parkUntil()`。

补充：
sleep和yield的不同之处：

- sleep(long)方法会使线程转入超时等待状态，时间到了之后才会转入就绪状态。而yield()方法不会将线程转入等待，而是强制线程进入就绪状态。
- 使用sleep(long)方法需要处理异常，而yield()不用。

###### 超时等待->就绪

- 同样的，等待的线程被其他线程对象唤醒，`notify()`和`notifyAll()`。
- `LockSupport.unpark(Thread)`。

##### 消亡状态

即线程的终止，表示线程已经执行完毕。前面已经说了，已经消亡的线程不能通过start再次唤醒。

- run()和call()线程执行体中顺利执行完毕，线程正常终止。
- 线程抛出一个没有捕获的Exception或Error。

需要注意的是：主线成和子线程互不影响，子线程并不会因为主线程结束就结束。

### 线程池实现原理与应用场景

[线程池的作用，应用场景与原理_canfengli的博客-CSDN博客_线程池的作用](https://blog.csdn.net/canfengli/article/details/78033943)

[常用线程池的工作原理和使用场景_q865165648的博客-CSDN博客](https://blog.csdn.net/q865165648/article/details/104278622)

#### 线程池的作用

1.减少在创建和销毁线程上所花的时间以及系统资源的开销 。

2.如不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存以及”过度切换”。

线程池，就是在调用线程的时候初使化一定数量的线程，有线程过来的时候，先检测初使化的线程还有空的没有， 没有就再看当前运行中的线程数是不是已经达到了最大数，如果没有，就新分配一个线程去处理， 就像餐馆中吃饭一样，从里面叫一个服务员出来；但如果已经达到了最大数，就相当于服务员已经用完了，那没得办法，另外的线程就只有等了，直到有新的“服务员”为止。

线程池的优点就是可以管理线程，有一个高度中枢，这样程序才不会乱，保证系统不会因为大量的并发而因为资源不足挂掉。

#### 线程池的应用场景

1.单个任务处理的时间比较短 

2.需处理的任务的数量大

#### 线程池原理

线程池类为 java.util.concurrent.ThreadPoolExecutor，常用构造方法为：

```html
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,
long keepAliveTime, TimeUnit unit,
BlockingQueue<Runnable> workQueue,
RejectedExecutionHandler handler)
corePoolSize： 线程池维护线程的最少数量
maximumPoolSize：线程池维护线程的最大数量
keepAliveTime： 线程池维护线程所允许的空闲时间
unit： 线程池维护线程所允许的空闲时间的单位
workQueue： 线程池所使用的缓冲队列
handler： 线程池对拒绝任务的处理策略
unit可选的参数为java.util.concurrent.TimeUnit中的几个静态属性：
NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS。
workQueue我常用的是：java.util.concurrent.ArrayBlockingQueue
handler有四个选择：
ThreadPoolExecutor.AbortPolicy()
抛出java.util.concurrent.RejectedExecutionException异常
ThreadPoolExecutor.CallerRunsPolicy()
重试添加当前的任务，他会自动重复调用execute()方法
ThreadPoolExecutor.DiscardOldestPolicy()
抛弃旧的任务
ThreadPoolExecutor.DiscardPolicy()
抛弃当前的任务
```

当一个任务通过execute(Runnable)方法欲添加到线程池时：
如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。

如果此时线程池中的数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。

如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。

如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。

也就是：处理任务的优先级为：
核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。

当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。

![img](https://img-blog.csdnimg.cn/20200212162652453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3E4NjUxNjU2NDg=,size_16,color_FFFFFF,t_70)

### 悲观锁与乐观锁

[什么是悲观锁，什么是乐观锁 - 简书 (jianshu.com)](https://www.jianshu.com/p/d2ac26ca6525)

##### 悲观锁(Pessimistic Lock)

当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。

悲观锁，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界(包括本系统当前的其他事务，以及来自外部系统的事务处理)修改持保守态度。因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制(也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据)。

![img](https:////upload-images.jianshu.io/upload_images/7038163-ea0875b10d5864c7.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1080/format/webp)

之所以叫做悲观锁，是因为这是一种对数据的修改持有悲观态度的并发控制方式。总是假设最坏的情况，每次读取数据的时候都默认其他线程会更改数据，因此需要进行加锁操作，当其他线程想要访问数据时，都需要阻塞挂起。悲观锁的实现：

1. 传统的关系型数据库使用这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
2. Java 里面的同步 [synchronized](https://www.jianshu.com/p/c8f997e7f75c) 关键字的实现。

##### 乐观锁(Optimistic Locking)

乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量。

![img](https:////upload-images.jianshu.io/upload_images/7038163-dea06d00a74071fb.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp)

乐观锁机制采取了更加宽松的加锁机制。乐观锁是相对悲观锁而言，也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制，但乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。乐观锁的实现：

1. CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。
2. 版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会+1。当线程A要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。

### JDK锁机制

#### Synchronized

synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： 

　　1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 
　　2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 
　　3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 
　　4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。

#### Lock

java.util.concurrent.locks包下常用的类与接口（lock是jdk 1.5后新增的）

ock接口有6个方法：

```
// 获取锁  
void lock()   
// 如果当前线程未被中断，则获取锁，可以响应中断  
void lockInterruptibly()   
// 返回绑定到此 Lock 实例的新 Condition 实例  
Condition newCondition()   
// 仅在调用时锁为空闲状态才获取该锁，可以响应中断  
boolean tryLock()   
// 如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁  
boolean tryLock(long time, TimeUnit unit)   
// 释放锁  
void unlock()  
```

#### ReadWriteLock

ReadWriteLock 接口只有两个方法：

```
//返回用于读取操作的锁  
Lock readLock()   
//返回用于写入操作的锁  
Lock writeLock() 
```

ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持，而写入锁是独占的。

### 死锁的产生与避免

死锁通常被定义为：如果一个进程集合中的每个进程都在等待只能由此集合中的其他进程才能引发的事件，而无限期陷入僵持的局面称为死锁。

#### 死锁产生的条件

- 互斥条件

  > 临界资源是独占资源，进程应互斥且排他的使用这些资源。

- 占有和等待条件

  > 进程在请求资源得不到满足而等待时，不释放已占有资源。

- 不剥夺条件

  > 又称不可抢占，已获资源只能由进程自愿释放，不允许被其他进程剥夺。

- 循环等待条件

  > 又称环路条件，存在循环等待链，其中，每个进程都在等待链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态。

#### 死锁产生的原因

死锁产生的原因有很多，如：

- 进程顺序不当
- PV操作使用不妥
- 同类资源分配不均
- 对某些资源的使用未加限制

等等。

> 可见，产生死锁的原因不仅与系统拥有的资源数量有关，而且与资源分配策略、进程对资源的使用要求以及进程的推进顺序有关。

#### 死锁解决的方法

主要有一下三种方法：

- 死锁防止

  在程序运行之前防止发生死锁。

  前面说了死锁产生的条件有四个，分别是：互斥条件、占有和等待条件、不剥夺条件、循环等待条件。

  而死锁防止的策略就是至少破坏这四个条件其中一项。

- 死锁避免

  在程序运行时避免发生死锁。

  各种死锁防止方法能够防止发生死锁，但必然会降低系统并发性，导致低效的资源利用率。

- 死锁检测和恢复

  不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

  对资源的分配加以适当限制可防止或避免死锁发生，但不利于进程对系统资源的充分共享。

### 阻塞队列与线程协作机制

阻塞队列，**主要操作**有两个，一个是**put**放入元素，另一个是**take**取出元素。所谓的阻塞就是当多个线程同时存取数据时，如果遇到队列为空或者队列为满时，会发生阻塞。并且多个线程同时执行take或者put操作时，某一时刻只有一个线程获得执行权利，也就是执行任何一个操作之前需要获得锁，没有获得锁的线程发生阻塞。

**put:** 向队列中存入一个元素，如果已满，则阻塞当前线程，等待唤醒。如果正常存入了元素，那么唤醒其他阻塞的线程（有些执行take操作的线程因为队列为空而阻塞）

**take:** 从队列中取一个元素，如果队列为空，则阻塞当前线程，等待唤醒。如果正常取出了元素，那么唤醒其他阻塞的线程（有些执行put操作的线程因为队列满而阻塞）

Object类提供了几个操作来进行**当前线程的唤醒和阻塞**。
**wait:** 阻塞当前线程，其实就是将当前线程放入当前对象的等待集中，释放锁（如果持有锁的话），暂停当前线程。
**notify:** 唤醒当前对象等待集上的一个线程。
**notifyAll:** 唤醒当前对象等待集上的所有线程。

### 抽象队列化同步器AQS

[抽象队列式同步器AQS详解_zycxnanwang的博客-CSDN博客](https://blog.csdn.net/zycxnanwang/article/details/105319282)

AQS，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，ReetrantLock、Semaphore、CountDownLatch的实现均依赖于AQS,所以详细了解其源码实现，有助于理解依赖其实现的锁和同步器。

AQS维护一个双向的FIFO阻塞队列和一个volatile int类型的成员变量，如图所示，其实简而言之，多个线程同时对资源进行抢占时，失败的线程会添加到阻塞队列中，进入一个阻塞等待的状态。当线程使用完资源后，会相应得唤醒队列中得阻塞线程。

![img](https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLmpob25yYWluLm9yZy9hcXMvQVFTX1N0cnVjdHVyZS5wbmc?x-oss-process=image/format,png)

AQS通过**head**, **tail**成员变量，维护一个双向FIFO阻塞队列，head、tail均为Node类型。

Node的waitStatus共有四种状态

- `CANCELLED`(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。
- `SIGNAL`(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。
- `CONDITION`(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将**从等待队列转移到同步队列中**，等待获取同步锁。
- `PROPAGATE`(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。
- `0`：新结点入队时的默认状态。

**负值表示结点处于有效等待状态，而正值表示结点已被取消。**

AQS支持两种资源模式，一是独占资源(`EXCLUSIVE`)，二是共享资源(`SHARED`).

`Node.mode == EXCLUSIVE`，代表其阻塞于等待独占资源

`Node.mode == SHARED`,代表其阻塞于等待共享资源。

## JVM分析与调优

[Java虚拟机（JVM）你只要看这一篇就够了！_Java笔记-CSDN博客_jvm](https://blog.csdn.net/qq_41701956/article/details/81664921)

![img](https://img-blog.csdn.net/20180808112156511?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eXV5YW5nNjY4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### Java 内存区域与内存溢出异常

#### 运行时数据区域

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGQzYjE1YjNkODgyNmZhZWFlMjA2Mzk3NmZiOTkyMTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGE3N2Q5MDE0Njc4NmMwY2IzZTE3MGI5YzkzNzZhZTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

##### 程序计数器

> 内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成

如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为 (Undefined)。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

##### Java 虚拟机栈

> 线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储`局部变量表`、`操作数栈`、`动态链接`、`方法出口`等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。

局部变量表：存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)

StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。
OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。

##### 本地方法栈

> 区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。也会有 StackOverflowError 和 OutOfMemoryError 异常。

##### Java 堆

> 对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。

OutOfMemoryError：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。

##### 方法区

> 属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

##### 运行时常量池

> 属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。

##### 直接内存

> 非虚拟机运行时数据区的部分

在 JDK 1.4 中新加入 NIO (New Input/Output) 类，引入了一种基于通道(Channel)和缓存(Buffer)的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。可以避免在 Java 堆和 Native 堆中来回的数据耗时操作。
OutOfMemoryError：会受到本机内存限制，如果内存区域总和大于物理内存限制从而导致动态扩展时出现该异常。

### 垃圾回收器与内存分配策略

程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道那些对象会创建，这部分内存的分配和回收都是动态的，垃圾回收期所关注的就是这部分内存。

#### 垃圾回收算法

标记 —— 清除算法

> 直接标记清除就可。

两个不足：

- 效率不高
- 空间会产生大量碎片

#### 复制算法

> 把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。

解决前一种方法的不足，但是会造成空间利用率低下。因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。

#### 标记-整理算法

> 不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是把存活对象移到内存的一端。

#### 分代回收

> 根据存活对象划分几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法。

新生代

> 每次垃圾回收都有大量对象死去，只有少量存活，选用复制算法比较合理。

老年代

> 老年代中对象存活率较高、没有额外的空间分配对它进行担保。所以必须使用 `标记 —— 清除` 或者 `标记 —— 整理` 算法回收。

### Java 内存模型与线程

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjBhOTk2ODc0NmFmYTJhZmRlNGIzNzE2YmFiZjU1Y2U_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

#### Java 内存模型

> 屏蔽掉各种硬件和操作系统的内存访问差异。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOGY5ODMzMGRjOGFmNGNlOGNmNTM5N2EwMTMzMDhlYzI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

#### Java 与线程

使用内核线程实现

> 直接由操作系统内核支持的线程，这种线程由内核完成切换。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口 —— 轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNGMwYTk1OTQ1ZTdjN2E1MmVmNmNjYmE0YWJiNzNkNDM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

##  Linux性能监控与调优 CPU监控与调优

### 网络协议

#### TCP

传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 定义。

TCP旨在适应支持多网络应用的分层协议层次结构。 连接到不同但互连的计算机通信网络的主计算机中的成对进程之间依靠TCP提供可靠的通信服务。TCP假设它可以从较低级别的协议获得简单的，可能不可靠的数据报服务。 原则上，TCP应该能够在从硬线连接到分组交换或电路交换网络的各种通信系统之上操作。

TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂， 只简单的描述下这三次对话的简单过程：

1）主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；

2）主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包 ：“可以，你什么时候发？”，这是第二次对话；

3）主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”， 这是第三次对话。

三次“对话”的目的是使数据包的发送和接收同步， 经过三次“对话”之后，主机A才向主机B正式发送数据。

TCP三次握手过程

第一次握手：主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。

第二次握手：主机B 收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我

第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段："我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机A和主机B 就可以传输数据了。

3次握手的特点

没有应用层的数据 ,SYN这个标志位只有在TCP建立连接时才会被置1 ,握手完成后SYN标志位被置0。

TCP建立连接要进行3次握手，而断开连接要进行4次

第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ；

第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1；

第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ；

第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束.。

由TCP的三次握手和四次断开可以看出，TCP使用面向连接的通信方式， 大大提高了数据通信的可靠性，使发送数据端和接收端在数据正式传输前就有了交互， 为数据正式传输打下了可靠的基础。

#### UDP

UDP（User Data Protocol，用户数据报协议）,[Internet ](https://baike.baidu.com/item/Internet /272794)协议集支持一个无连接的[传输协议](https://baike.baidu.com/item/传输协议/8048821)，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为[应用程序](https://baike.baidu.com/item/应用程序/5985445)提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。RFC 768 描述了 UDP。

Internet 的传输层有两个主要协议，互为补充。无连接的是 UDP，它除了给应用程序发送数据包功能并允许它们在所需的层次上架构自己的协议之外，几乎没有做什么特别的事情。面向连接的是 [TCP](https://baike.baidu.com/item/TCP/33012)，该协议几乎做了所有的事情。

1、UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。

2、 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。

3、UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。

4、吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。

5、UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。

6、UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。

我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常， 其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。

ping命令是用来探测主机到主机之间是否可通信，如果不能ping到某台主机，表明不能和这台主机建立连接。ping命令是使用 IP 和网络控制信息协议 (ICMP)，因而没有涉及到任何传输协议(UDP/TCP) 和应用程序。它发送icmp回送请求消息给目的主机。

ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。

#### HTTP

[HTTP 消息结构 | 菜鸟教程 (runoob.com)](https://www.runoob.com/http/http-messages.html)

超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在[TCP](https://baike.baidu.com/item/TCP/33012)之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以[ASCII](https://baike.baidu.com/item/ASCII/309296)形式给出；而消息内容则具有一个类似[MIME](https://baike.baidu.com/item/MIME/2900607)的格式。这个简单模型是早期[Web](https://baike.baidu.com/item/Web/150564)成功的有功之臣，因为它使开发和部署非常地直截了当。

#### HTTPS

[HTTP 与 HTTPS 的区别 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/http-vs-https.html)

HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：

- 1、TCP 三次同步握手
- 2、客户端验证服务器数字证书
- 3、DH 算法协商对称加密算法的密钥、hash 算法的密钥
- 4、SSL 安全加密隧道协商完成
- 5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。

### 内存监控与调优

### 磁盘监控与调优

### 网络监控与调优