# 设计模式

## 开篇

学会编写高质量代码，要从细节抓起，不要因小失大，高质量的代码都是通过一点点的细节积累起来的。

最好的方式就是通过1对1的方式，有一个又能力的导师或者同事一步步去检查你的代码，给你意见，帮助你快速成长。

## 导读

### 第一章

为什么要学习设计模式？

1.能看懂源码和复杂模块的编码。

2.能设计优质的复杂模块。

3.让你带的新人、同事、领导甚至客户信服，做到有理可依。

4.可以减少BUG，便于重构和维护。

5.有利于面试和职场发展。

### 第二章

对于质量好坏很难有具体可遵循的标准，往往主观性比较强。

以下几种常用评判标准。

1.可维护性⭐：不破坏原有代码的结构，可以没有风险的快速添加功能/修改bug。

2.可读性⭐：好的程序员是能写出人看的懂的代码。

3.可扩展性⭐：预留了可扩展的方式，不用大面积代码修改便可以实现扩展。

4.灵活性：易扩展、易复用、易用。

5.简洁性：KISS原则（尽可能提供最简单的结果），用尽可能最简单的代码解决问题。

6.可复用性：减少重复代码。

7.可测试性：易于测试单元编写。

### 第三章

主流的编程风格：

1.面向过程

2.面向对象

3.函数式编程

面向对象的四大特性

1.封装

2.抽象

3.继承

4.多态

面向对象是基础，设计原则是指导，设计模式是实现，代码规范可以提高可读性，重构可以提高代码质量并且长期保持。

## 面向对象

### 第一章

面向对象

OOP：面向对象编程-一种以类为基本单元，围绕四大特性为依据的编程风格和规范。

OOPL：面向对象编程语言-一种实现工具。

只要针对类和对象分析、设计和实现的，从广义上都认定是面向对象编程。

UML：统一建模语言，因为学习成本和沟通成本比较高，所以一般用简图可表明意思即可。

### 第二章

四大特性

封装：屏蔽内部信息，只能通过暴露的有限访问，提供必要的功能。

抽象：只关注功能点，不暴露具体实现。

继承：代码复用，不要继承的层级和结构过于复杂。

多态：提高可扩展性。

### 第三章

面向过程

OOP：面向过程编程-一种以过程为基本单元，以数据和方法相分离，拼接一组可执行顺序的编码风格和规范。

OOPL：面向过程编程语言-一种实现工具，不支持类和对象，只支持过程。

面向过程编程和面向对象编程的不同：

1.OOP更适合应对大规范复杂程序的编程。

2.OOP更易复用、易扩展、易维护。

3.OOP语言使用更人性化、更高级、更方便。

### 第四章

看似是面向对象，实际是面向过程：

1.滥用get、set方法

   尽量不要定义set方法，违反了抽象的定义。get方法返回的是一个对象，也尽量不要使用，因为有修改内部数据的可能。

2.Constants和Utils类

   数据和方法分离，尽量放到使用的类中。次之，按照功能模块划分具体的Constants和Utils类

3.基于贫血模式的开发模式

VO/Entity和Controller/Service/Pepository数据和方法分离。

### 第五章

接口和抽象类的区别

抽象类：

1.抽象类不允许被实例化，只能被继承。

2.抽象类中可以用属性、方法（实现逻辑）和抽象方法（不实现逻辑）

3.子类必须实现父类的所有抽象方法。

※需要符合is-a(继承关系)

接口：

1.接口不能包含属性。

2.接口中的方法只能声明，不能有具体逻辑。

3.实现接口，必须实现接口中的所有方法。

※需要符合has-a(包含关系)

适用场景

抽象类：

减少代码复用，是一种自下而上的设计思路（发现相同模块的类中有相同逻辑的代码，所以提出的父类）。

接口：

解耦，是一种自上而下的的设计思路（在设计初期为了解耦而设计，并向下扩展）。

### 第六章

基于接口/抽象而非现实编程

1.函数命名不应暴露实现细节，例如：upLoadToAliyun();

2.封装具体的实现细节，不应对外暴露。

3.依赖接口编程。

将实现和接口分离，隐藏不稳定的实现，开放稳定的接口，依赖接口实现。

不要过度使用接口。

### 第七章

组合优于继承，多用组合少用继承。

继承最大的问题在于：继承层次过深、继承关于过于复杂、会影响到代码的可读性和可维护性。

可以通过接口、组合、委托三个手段替代继承。

如果类之间的继承结构稳定、继承层次较浅、继承关系不复杂，可以使用继承。

如果继承结构不稳定、继承层次较深、继承关系复杂，尽量使用组合来替代继承。

特殊场景：例如不能修改的类，只能通过继承来实现修改。

疑问：VO、BO、Entity等类内容基本一致，应该如何让解决。

### 实战一（上）

贫血模式：传统的MVC框架，是面向过程编程，主要表现在Service和Bo的数据方法分离。

充血模式：领域驱动设计-DDD（Domain Driven Design），微服务推动了其发展，在service的基础上增加domain层。

为什么贫血模式是面向过程编程还如此收欢迎？

1.当下系统业务相对简单，不需要使用到充血模式。

2.充血模式设计比较有难度。

3.使用习惯、运行相对稳定、转型有成本。

充血模式适合的应用场景？

更适合业务更复杂的项目。

使用充血模式编程，需要我们在前期设计阶段投入更多的精力，设计领域模型。

### 实战一（下）

实战-利用传统和DDD两种模式实现虚拟钱包系统

基础功能：

1.充值

1.1增加金额

1.2增加交易记录

2.支付

2.1从一个账户转到另一个账户

2.2增加交易记录

3.提现

3.1扣减金额

3.2增加交易记录

4.查询余额

5.查询交易记录

*虚拟钱包系统不应感知具体的交易类型，应在上层在追加一条带有交易类型的流水。

实现：

传统模式：略

DDD模式：将Service中的逻辑迁移到Domain层中，Domian层不依赖与其他层，由Service层与其他层交互（例如Respository层）

### 实战二（上）

通过鉴权功能-进行面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP）。

面向对象分析（OOA）：

这是一个不断迭代优化的过程。

分析出鉴权功能最终功能：

1.请求时，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。

2.微服务端在接收到调用方的接口请求之后，从请求中拆解出 token、AppID、时间戳。

3.微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。

4.如果 token 验证没有过期失效，微服务端再从自己的存储中，取出 AppID 对应的密码，通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进行匹配；如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。

### 实战二（下）

通过鉴权功能-进行面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP）。

面向对象设计（OOD）：

1.通过职能划分不同的类（建模）

可以将分析的结果拆分成一个一个小的功能点，然后进行合并

鉴权功能点列表：

①把 URL、AppID、密码、时间戳拼接为一个字符串；

②对字符串通过加密算法加密生成 token；

③将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；

④解析 URL，得到 token、AppID、时间戳等信息；

⑤从存储中取出 AppID 和对应的密码；

⑥根据时间戳判断 token 是否过期失效；

⑦验证两个 token 是否匹配；

划分后的类：

AuthToken：负责实现①、②、⑥、⑦ 这四个操作；

Url ：负责 ③、④ 两个操作；

CredentialStorage ：负责 ⑤ 这个操作。

2.定义属性和方法

AuthToken：

①把 URL、AppID、密码、时间戳拼接为一个字符串；

②对字符串通过加密算法加密生成 token；根据时间戳判断 token 是否过期失效；验证两个 token 是否匹配。

Url ：

将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；

解析 URL，得到 token、AppID、时间戳等信息。

CredentialStorage ：

从存储中取出 AppID 和对应的密码。

※并不是所有的属性都需要放到类中，例如AppID、密码、时间戳等都是作为参数传递的。

​     会有分出以外的属性和方法的追加。

​     不要将模型限制到某一领域，比如URL可以改成ApiRequest。

3.定义类之间的交互关系。

UML统一建模语言划分了6种

・泛化（继承）

・实现（接口）

・聚合（包含）

・组合（包含）

・关联（弱相关）

・依赖（超级弱相关）

※在记忆的时候可以将聚合、组合、关联 统一为组合（包含）

4.将类拼装并提供入口

## 设计原则

### 第一章：单一职责原则

SOLID原则

・单一职责原则

・开闭原则

・里式替换原则

・接口隔离原则

・依赖反转原则

单一职责原则（SRP）：一个类或者模块只负责完成一个职责或者功能。

是否是单一职责要结合业务来看，不同的业务场景下对单一原则的定义可能不一致。

例如：在用户信息中添加地址信息，在不同的用户场景下是否符合单一职责原则就不尽相同了。

是否符合单一职责也是个比较主观的问题，以下是几条指导性的意见：

・类中的代码行数、函数或属性过多。（200行，10个属性？）

・依赖太多的类。

・私有方法过多，应考虑是否需要抽共同。

・对其中某几个属性操作特别多，考虑单独抽出一个类。

类的职责并不是设计的越单一越好。例如：Serializer和Deserializer类分开容易造成序列化/反序列化不统一。

### 第二章：开闭原则

开闭原则（OCP）：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。

开闭原则是可以针对不同粒度的，例如方法、类、模块等。

只要增加需求，对代码进行扩展，就不能做到一点代码不修改，只要不涉及到核心代码，一般就认为不违反开闭原则。

能体现开闭原则的实现：多态、依赖注入、抽象思想。

不要过度预留扩展接口，预留目之所及的扩展接口即可。

### 第三章：里式替换原则

里式替换原则（LSP）：子类能够替换程序中父类出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。

简单理解就是创建子类时，不改变入参、出参、异常、流程等因素，只实现具体过程。

里氏替换和多态的区别：

・多态是一种代码实现思路。

・里氏替换是指导如何设计子类的。

违反里氏替换原则的例子：

・子类违背父类要实现的功能，例如改变出参数据排序方式。

・子类违背父类对输入、输出、异常的约定，例如改变入参类型，返回null还是空对象，抛出异常类型等等。

・子类违背父类注释中的事项。

总结：按照协议来设计，只能扩展父类，而不要修改父类。

### 第四章：接口隔离原则

里式替换原则（ISP）：客户端不应该被强迫依赖它不需要的接口，其中的客户端可以理解成为接口的调用者或使用者。

・把接口理解为一组API接口集合

​    需要单独提供的接口需要单独提供，不要强加给所有的客户端。

・把接口理解为单个API接口或函数

​    应该分成粒度更细的函数。

・把接口理解为OOP中的接口概念

​    不要让实现调用者调用无效接口。

※接口隔离与单一职责的区别，前者更注重对接口的设计。

### 第五章：依赖反转原则

依赖反转原则/依赖倒置原则（DIP）：高层模块不要依赖低层模块，高层模块和底层模块应该通过抽象来相互依赖。除此之外，抽象不要依赖具体实现细节，具体实现依赖抽象。

※主要用来指导框架层面的设计

控制反转（IOC）：原本应该是程序员控制代码，但是通过框架设计，让框架控制程序员编程。

依赖注入（DI）：不通过new 的方式实现类，而通过注入、传递等方式实现。

### 第六章：KISS原则和YAGNI原则

KISS原则：尽量保持简单。

※不是代码量越少就越简单，需要考虑可读性、编程复杂度等因素，综合考量。

编程过程中如何保持KISS原则？

・尽量不要写大家不懂的语法。

・尽量使用已有类库的功能。

・不要过度优化。

YAGNI原则：不要过度设计。

※只预留预留接口，不需要的功能不要提前实装，不要引用当前用不到的jar包。

### 第七章：DRY原则

DRY原则：不要写重复的代码。

・实现逻辑重复

例如：校验用户和校验密码，可能代码是完全相同的，但是由于业务逻辑不同，放到一起反而会违反单一原则，应该使用更小的粒度拆分共通逻辑。

・功能语义重复

例如：不同的开发者写出对同一实现写出不同的逻辑，虽然代码可能不一致，但是语义是相同的。

・代码执行重复

例如：虽然在不同的模块，但是都调用了密码校验，连接数据库等功能做相同操作。

如何提高代码复用性？

・减少代码耦合，越独立的模块越容易被复用

・满足单一职责原则

・代码模块化

・业务与非业务逻辑分离

・通用代码下沉

・四大原则

・设计模式

・要有复用的意识。

Rule  of  Three：只有第2/3次在开始考虑复用的问题。

### 第八章：迪米特法则

迪米特法则/最小知识原则（LOD）：每个模块只应该了解与它关系密切的模块的有限知识。

※为了实现高内聚、松耦合。高内聚是指类本身的设计（相近的功能放到同一个类，易于集中修改），松耦合用来指导类之前依赖关系的设计。

・不应该有直接依赖关系的类，不要有依赖。

例：简化版搜索引擎爬取网页功能（功能分成以下三个模块）：

1.网络通信类

2.html下载类

3.文档提取等相关处理类。

浅析：因为网络通信类是底层网络通信类，所以应该让其尽可能通用，而不是只为html服务，所以可以把两个类之间的依赖关系变为具体的字段，网络通信类只需要知道下载文档的"地址"和“数据”信息即可，松开网络通信类与html下载类之间的依赖关系。

・有依赖关系的类之间，尽量只依赖必要的接口。

例：序列化/反序列化

相对适合的解决方案：

①序列化类：serializer      

②反序列化类：deSerializer      

③序列化/反序列化类：serialization 实现serializer接口和deSerializer接口

### 实战一（上）

业务系统从需求分析到上线维护的整个开发过程-积分兑换系统。

要学会**借鉴**已有的程序和设计等。

1.需求分析

通过借鉴和迭代的方式进行需求分析，再通过线框图、用户用例、用户故事等来挖掘需求细节。

积分兑换系统功能需求：

・积分赚取和兑换规则

・积分消费和兑换规则

・积分及明细查询

2.系统设计

可以利用设计原则和模式来对系统进行设计。

①划分功能模块

推荐：积分系统只做增减积分和查询功能，其他内容放到上层的营销系统中去，做到业务和逻辑分离。

②设计模块间通信

・同步通信

・异步通信

③设计接口、数据库、业务模型

### 实战一（下）

为什么要分MVC三层开发？

①起到代码复用的作用，例如：共通Service。

②起到隔离变化的作用，利用抽象思想，每层改动不会影响或者很少影响其他层面的代码。

③起到单一原则，很清楚每层的意思。

④提高代码可测试性，例如：MOCK数据库。

⑤应该系统复杂性，当系统复杂到一定程度时，需要扩展。水平扩展就是模块化，垂直扩展就是分层。

VO、BO、Entity代码基本一致，要不要统一？

・还是会有差异在，例如：VO层不会存储Password。

・代码重复，但是语义不重复。

・减少耦合，责任明确。

可以通过继承和组合的方式减少代码重复。

3.代码实现

### 实战二（上）

非业务通用框架-性能计数器

1.需求分析

・功能性需求分析

通过线框图，将需求罗列出来，便于整理和分析。

・非功能性需求分析

①易用性->方便、文档

②性能->无明显影响性能

③扩展性->为框架拓展需求

④容错性->异常处理

⑤通用性

2.框架设计

利用TDD（测试驱动开发）和Protptype（最小原则），从一个**简单的原型**开始设计，不断迭代。

例如：写一个算法前，可以先做几组测试数据。

・数据采集

・存储：异步

・聚合统计

・显示

### 实战二（下）

小步快跑，逐步迭代。

3.代码实现

①通过职能划分不同的类（建模）

②定义属性和方法

③定义类之间的交互关系。

④将类拼装并提供入口

4.Review设计和实现

**※※※不断重构和优化。**

## 规范与重构

### 第一章

重构的目的、对象、时机和方法

1.目的：

・保证代码持续性的质量。

・最开始是简单的，需要重构迭代升级。

・避免初期过度设计。

・提高程序员的重构能力。

2.对象：

・大型重构（系统、模块、结构、类之间关系等）

・小型重构（类、函数、变量）

3.时机：

持续重构。

4.方法：

・大型重构方法

提前做好完善的重构计划，按阶段实现，完成一阶段，测试运行，保证每个阶段后代码都是可以正常运行的。

・小型重构（类、函数、变量）

可以借助检查工具。P3C、Findbugs，CheckStyle等。

### 第二章

保证重构手段-单元测试

1.什么是单元测试？

UT-代码层级的测试（JUnit等）

2.为什么要写单元测试？

保证质量最有效的两个手段之一： 单元测试和Code Review

①有效发现BUG

②能够发现设计的不足（不容易写单元测试）

③可以模拟很多难以在集合测试中实现的测试场景（例如网络超时、边界值等）。

④自我重构的过程

⑤能够快速帮助阅读人读懂功能。

⑥TDD-测试驱动开发

3.如果编写单元测试

利用测试框架（JUnit，TestNG、Spring test、Testing等）

※

・虽然繁琐，但不耗时

・可以稍微降低单元测试代码质量

・覆盖率不能完全代表质量

・不要依赖被测试代码的内部逻辑来编写单元测试。

・单元测试框架无法测试，多半是因为代码写的不好。

### 第三章

代码的可测试性-容易编写单元测试。

依赖注入是实现代码可测试性的最有效的手段。

通过Mock解依赖。

测试性不好的函数

・未决行为，结果输出不确定，例如时间，随机数等有关的代码。

・全局变量，执行顺序导致结果不一致。

・静态方法？  可用用PowerMock解决

・复杂继承关系

・高耦合代码，需要大量Mock代码，非常麻烦。

### 第四章

解耦

如何解耦:

・封装和抽象

・中间层，中间层也可以作为重构的过度作用。

・模块化-分而治之

・其他设计思想和原则

①单一职责

②基于接口编程

③依赖注入

④多组合少继承

⑤迪米特法则

### 编程规范（上）

・命名

1.长度

常用的缩写可以使用

作用域小的可以相对缩写

作用域大的尽量用长的

※能准确达意为目标

2.利用上下文简化命名

例如User.name, User.password

3.命名要可读、可搜索。

容易读写和记忆

风格统一，例如查询用SelectXXX，保存用insertXXX

4.命名接口和抽象类

项目统一

・注释

注释是命名的补充。

5.注释内容

格式：做什么-为什么-怎么做

6.注释是不是越多越好？

一般类和函数一定要写，函数内部通过命名来提高可读性。

### 编程规范（中）

・代码风格

7.类和函数的长度

过多阅读不便，过少需要多来回跳转，所以要适中。（推荐  函数：一竖屏的长度，类：200行）

8.代码行的长度

最长不要超过显示区域的长度，不要有滚动条，但也不要切分的过细，导致过多的折行。

9.善于使用空格分隔代码块

10.缩进

①四格缩进（PHP）

②两个缩进（Java），好处是多层缩进后，相对四格缩进，不易使代码折行。

※项目统一、遵从大厂的开源代码规则、不要用Tab键。

11.大括号是否要另起一行

①在代码最后：减少代码行数

②另起一行：开始和结束在一列，比较清晰的能区别代码块。

12.类中成员的排列顺序

依赖：按字母排列a-z

成员变量和函数：先静态，后普通

函数：按照作用域排序：public -> protected -> private

### 编程规范（下）

・编程技巧

13.把代码分割成更小的单元块

可以抽出方法，也可以利用第9条用空格区分。

14.避免参数过多

推荐不大于4个。

解决：可以通过划分更小粒度函数和将参数封装成对象两种方法。

15.不要用参数来控制函数。

例如用boolean型来区分函数执行内容是不被推荐的，可以分成不同的函数。

16.函数设计职责要单一

函数级别因为粒度比较小，最好做到尽可能的职责单一。

17.移除过深层次的嵌套

循环、判断等。

18.使用魔法值

19.使用解释性变量来解释复杂表达式

例如：IF语句中的判定式。

・统一编码规范

项目要做到编码规范统一，并通过Code Review督促执行。

### 实战一（上）

ID生成器-重构代码

如何发现代码质量问题？

①是否满足“高内聚、低耦合”

②是否遵循设计原则和设计思想

③是否过度设计

④是否易扩展

⑤是否可以复用

⑥是否易测试

⑦是否易读、符合编码规范

是否满足和业务相关的机能/非机能需求？

①是否符合业务需求

②逻辑是否正确，适用各种情况

③日志是否健全

④接口是否易用、是否符合幂等、事务等

⑤是否存在并发、线程是否安全

⑥性能是否可以优化

⑦是否有安全漏洞

### 实战一（下）

常用重构步骤：

①提高代码可读性

②提高代码可测试性

③编写单元测试

④添加注释

### 实战二（上）

函数异常返回

・返回错误码（C 语言）

・null

・空对象

・异常

①运行时异常->非受检异常（Runtime Exception）

②编译时异常->受检异常（Compile Exception）

### 实战二（下）

## 创建型设计模式

### 单例模式（上）

单例设计模式（Singleton Design Pattern）：一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。

**单例的用处**

・处理资源访问冲突

・表示全局唯一类

**单例的因素**

・构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；

・考虑对象创建时的线程安全问题；

・考虑是否支持延迟加载；

・考虑 getInstance() 性能是否高（是否加锁）。

**单例的实现**

・饿汉式：在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载。

・懒汉式：支持延迟加载，但是有性能问题，不支持高并发。

・双重检测：支持延迟加载、又支持高并发的单例实现方式。先检查是否创建，null的情况就创建，否则就不会创建。

・静态内部类：。它有点类似饿汉式，但又能做到了延迟加载。外部类首先被加载，但是内部静态类不会会创建，只有在调用外部类的方法时，才创建内部静态类中的示例。

・枚举：通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。

### 单例模式（中）

**单例存在哪些问题**

・单例对 OOP 特性的支持不友好（能做，但是比较怪异）

・单例会隐藏类之间的依赖关系（可读性差）

・单例对代码的扩展性不友好（可扩展性差），连接池等还是不做成单例会比较好，易扩展。

・单例对代码的可测试性不友好（可测试性差）

・单例不支持有参数的构造函数（因为只有第一次的参数被使用了，但是因为实例已经创建，所以后续的却没有使用。而且会使使用者误会。）

**替代解决方案**

・静态方法（部分解决）

・工厂模式

・IOC 容器

・程序员自己保证？

### 单例模式（下）

线程唯一是通过ThreadLocal(底层：HashMap("线程 ID","对象"))。

进程唯一还代表了线程内、线程间都唯一。单例模式创建的对象是进程唯一的。

集群唯一就是进程内唯一、进程间也唯一。（我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件））

多例模式指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。（例如枚举类型）

### 工厂模式（上）

工厂模式（Factory Design Pattern）

・简单工厂（Simple Factory）

・工厂方法（Factory Method）

・抽象工厂（Abstract Factory）

何时使用工厂方法而不是简单工厂

①创建过程涉及复杂的 if-else 分支判断。

②对象创建需要组装多个其他类对象或者需要复杂的初始化过程。

### 工厂模式（下）

DI 容器底层最基本的设计思路就是基于工厂模式的。BeansFactory

DI 容器的核心功能

・配置解析 @Bean

・对象创建

・对象生命周期管理

​    scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象。

​    lazy-init=true，对象在真正被使用到的时候才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好。

​    init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。

BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法

### 建造者模式

Builder Pattern

如果可配置项过多，就容易搞错各参数的顺序；

如果用构造方法+set方法的不足：1、必填项过多的话，2、校验，3、创建后不可变，4、可能会出现短暂的无效状态。

工厂模式和建造者模式的却别：

・工厂模式根据参数创造不同但相关的对象

・建造者模式根据可选参数定制化一种类型的复杂化对象。

### 原型模式

原型模式（Prototype Design Pattern）：利用对已有对象（原型）进行拷贝的方式来创建新对象。

深拷贝和浅拷贝

重新创建成本较大的情况下在考虑使用原型模式

浅拷贝：内存地址，索引

深拷贝：值，深层对象

深拷贝方式：1、递归拷贝对象；2、先将对象序列化，然后再反序列化成新的对象。

## 结构型设计模式

### 代理模式

代理模式（Proxy Design Pattern）：它在不改变原始类代码的情况下，通过引入代理类来给原始类附加功能。

实现代理

①代理类和被代理类实现同一接口

②代理类继承被代理类

③动态代理：AOP底层就是动态代理

代理模式常用在业务系统中开发一些非功能性需求。

### 桥接模式

桥接模式（Bridge Design Pattern）：将抽象和实现解耦，让它们可以独立变化，通过组合将其链接在一起。类似“组合优于继承”

JDBC 驱动是桥接模式的经典应用。

### 装饰器模式

装饰器模式：它的代码结构跟桥接模式非常相似，不过，要解决的问题却大不相同。

Java IO应用了装饰器模式（InputStream）

装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。

做一个增强功能的抽象方法，需要的都实现它。

