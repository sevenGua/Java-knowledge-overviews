# 设计模式

## 开篇

学会编写高质量代码，要从细节抓起，不要因小失大，高质量的代码都是通过一点点的细节积累起来的。

最好的方式就是通过1对1的方式，有一个又能力的导师或者同事一步步去检查你的代码，给你意见，帮助你快速成长。

## 导读

### 第一章

为什么要学习设计模式？

1.能看懂源码和复杂模块的编码。

2.能设计优质的复杂模块。

3.让你带的新人、同事、领导甚至客户信服，做到有理可依。

4.可以减少BUG，便于重构和维护。

5.有利于面试和职场发展。

### 第二章

对于质量好坏很难有具体可遵循的标准，往往主观性比较强。

以下几种常用评判标准。

1.可维护性⭐：不破坏原有代码的结构，可以没有风险的快速添加功能/修改bug。

2.可读性⭐：好的程序员是能写出人看的懂的代码。

3.可扩展性⭐：预留了可扩展的方式，不用大面积代码修改便可以实现扩展。

4.灵活性：易扩展、易复用、易用。

5.简洁性：KISS原则（尽可能提供最简单的结果），用尽可能最简单的代码解决问题。

6.可复用性：减少重复代码。

7.可测试性：易于测试单元编写。

### 第三章

主流的编程风格：

1.面向过程

2.面向对象

3.函数式编程

面向对象的四大特性

1.封装

2.抽象

3.继承

4.多态

面向对象是基础，设计原则是指导，设计模式是实现，代码规范可以提高可读性，重构可以提高代码质量并且长期保持。

## 面向对象

### 第一章

面向对象

OOP：面向对象编程-一种以类为基本单元，围绕四大特性为依据的编程风格和规范。

OOPL：面向对象编程语言-一种实现工具。

只要针对类和对象分析、设计和实现的，从广义上都认定是面向对象编程。

UML：统一建模语言，因为学习成本和沟通成本比较高，所以一般用简图可表明意思即可。

### 第二章

四大特性

封装：屏蔽内部信息，只能通过暴露的有限访问，提供必要的功能。

抽象：只关注功能点，不暴露具体实现。

继承：代码复用，不要继承的层级和结构过于复杂。

多态：提高可扩展性。

### 第三章

面向过程

OOP：面向过程编程-一种以过程为基本单元，以数据和方法相分离，拼接一组可执行顺序的编码风格和规范。

OOPL：面向过程编程语言-一种实现工具，不支持类和对象，只支持过程。

面向过程编程和面向对象编程的不同：

1.OOP更适合应对大规范复杂程序的编程。

2.OOP更易复用、易扩展、易维护。

3.OOP语言使用更人性化、更高级、更方便。

### 第四章

看似是面向对象，实际是面向过程：

1.滥用get、set方法

   尽量不要定义set方法，违反了抽象的定义。get方法返回的是一个对象，也尽量不要使用，因为有修改内部数据的可能。

2.Constants和Utils类

   数据和方法分离，尽量放到使用的类中。次之，按照功能模块划分具体的Constants和Utils类

3.基于贫血模式的开发模式

VO/Entity和Controller/Service/Pepository数据和方法分离。

### 第五章

接口和抽象类的区别

抽象类：

1.抽象类不允许被实例化，只能被继承。

2.抽象类中可以用属性、方法（实现逻辑）和抽象方法（不实现逻辑）

3.子类必须实现父类的所有抽象方法。

※需要符合is-a(继承关系)

接口：

1.接口不能包含属性。

2.接口中的方法只能声明，不能有具体逻辑。

3.实现接口，必须实现接口中的所有方法。

※需要符合has-a(包含关系)

适用场景

抽象类：

减少代码复用，是一种自下而上的设计思路（发现相同模块的类中有相同逻辑的代码，所以提出的父类）。

接口：

解耦，是一种自上而下的的设计思路（在设计初期为了解耦而设计，并向下扩展）。

### 第六章

基于接口/抽象而非现实编程

1.函数命名不应暴露实现细节，例如：upLoadToAliyun();

2.封装具体的实现细节，不应对外暴露。

3.依赖接口编程。

将实现和接口分离，隐藏不稳定的实现，开放稳定的接口，依赖接口实现。

不要过度使用接口。

### 第七章

组合优于继承，多用组合少用继承。

继承最大的问题在于：继承层次过深、继承关于过于复杂、会影响到代码的可读性和可维护性。

可以通过接口、组合、委托三个手段替代继承。

如果类之间的继承结构稳定、继承层次较浅、继承关系不复杂，可以使用继承。

如果继承结构不稳定、继承层次较深、继承关系复杂，尽量使用组合来替代继承。

特殊场景：例如不能修改的类，只能通过继承来实现修改。

疑问：VO、BO、Entity等类内容基本一致，应该如何让解决。

### 实战一（上）

贫血模式：传统的MVC框架，是面向过程编程，主要表现在Service和Bo的数据方法分离。

充血模式：领域驱动设计-DDD（Domain Driven Design），微服务推动了其发展，在service的基础上增加domain层。

为什么贫血模式是面向过程编程还如此收欢迎？

1.当下系统业务相对简单，不需要使用到充血模式。

2.充血模式设计比较有难度。

3.使用习惯、运行相对稳定、转型有成本。

充血模式适合的应用场景？

更适合业务更复杂的项目。

使用充血模式编程，需要我们在前期设计阶段投入更多的精力，设计领域模型。

### 实战一（下）

实战-利用传统和DDD两种模式实现虚拟钱包系统

基础功能：

1.充值

1.1增加金额

1.2增加交易记录

2.支付

2.1从一个账户转到另一个账户

2.2增加交易记录

3.提现

3.1扣减金额

3.2增加交易记录

4.查询余额

5.查询交易记录

*虚拟钱包系统不应感知具体的交易类型，应在上层在追加一条带有交易类型的流水。

实现：

传统模式：略

DDD模式：将Service中的逻辑迁移到Domain层中，Domian层不依赖与其他层，由Service层与其他层交互（例如Respository层）

### 实战二（上）

通过鉴权功能-进行面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP）。

面向对象分析（OOA）：

这是一个不断迭代优化的过程。

分析出鉴权功能最终功能：

1.请求时，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。

2.微服务端在接收到调用方的接口请求之后，从请求中拆解出 token、AppID、时间戳。

3.微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。

4.如果 token 验证没有过期失效，微服务端再从自己的存储中，取出 AppID 对应的密码，通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进行匹配；如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。

### 实战二（下）

通过鉴权功能-进行面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP）。

面向对象设计（OOD）：

1.通过职能划分不同的类（建模）

可以将分析的结果拆分成一个一个小的功能点，然后进行合并

鉴权功能点列表：

①把 URL、AppID、密码、时间戳拼接为一个字符串；

②对字符串通过加密算法加密生成 token；

③将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；

④解析 URL，得到 token、AppID、时间戳等信息；

⑤从存储中取出 AppID 和对应的密码；

⑥根据时间戳判断 token 是否过期失效；

⑦验证两个 token 是否匹配；

划分后的类：

AuthToken：负责实现①、②、⑥、⑦ 这四个操作；

Url ：负责 ③、④ 两个操作；

CredentialStorage ：负责 ⑤ 这个操作。

2.定义属性和方法

AuthToken：

①把 URL、AppID、密码、时间戳拼接为一个字符串；

②对字符串通过加密算法加密生成 token；根据时间戳判断 token 是否过期失效；验证两个 token 是否匹配。

Url ：

将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；

解析 URL，得到 token、AppID、时间戳等信息。

CredentialStorage ：

从存储中取出 AppID 和对应的密码。

※并不是所有的属性都需要放到类中，例如AppID、密码、时间戳等都是作为参数传递的。

​     会有分出以外的属性和方法的追加。

​     不要将模型限制到某一领域，比如URL可以改成ApiRequest。

3.定义类之间的交互关系。

UML统一建模语言划分了6种

・泛化（继承）

・实现（接口）

・聚合（包含）

・组合（包含）

・关联（弱相关）

・依赖（超级弱相关）

※在记忆的时候可以将聚合、组合、关联 统一为组合（包含）

4.将类拼装并提供入口

## 设计原则

### 第一章：单一职责原则

SOLID原则

・单一职责原则

・开闭原则

・里式替换原则

・接口隔离原则

・依赖反转原则

单一职责原则（SRP）：一个类或者模块只负责完成一个职责或者功能。

是否是单一职责要结合业务来看，不同的业务场景下对单一原则的定义可能不一致。

例如：在用户信息中添加地址信息，在不同的用户场景下是否符合单一职责原则就不尽相同了。

是否符合单一职责也是个比较主观的问题，以下是几条指导性的意见：

・类中的代码行数、函数或属性过多。（200行，10个属性？）

・依赖太多的类。

・私有方法过多，应考虑是否需要抽共同。

・对其中某几个属性操作特别多，考虑单独抽出一个类。

类的职责并不是设计的越单一越好。例如：Serializer和Deserializer类分开容易造成序列化/反序列化不统一。

### 第二章：开闭原则

开闭原则（OCP）：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。

开闭原则是可以针对不同粒度的，例如方法、类、模块等。

只要增加需求，对代码进行扩展，就不能做到一点代码不修改，只要不涉及到核心代码，一般就认为不违反开闭原则。

能体现开闭原则的实现：多态、依赖注入、抽象思想。

不要过度预留扩展接口，预留目之所及的扩展接口即可。

### 第三章：里式替换原则

里式替换原则（LSP）：子类能够替换程序中父类出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。

简单理解就是创建子类时，不改变入参、出参、异常、流程等因素，只实现具体过程。

里氏替换和多态的区别：

・多态是一种代码实现思路。

・里氏替换是指导如何设计子类的。

违反里氏替换原则的例子：

・子类违背父类要实现的功能，例如改变出参数据排序方式。

・子类违背父类对输入、输出、异常的约定，例如改变入参类型，返回null还是空对象，抛出异常类型等等。

・子类违背父类注释中的事项。

总结：按照协议来设计，只能扩展父类，而不要修改父类。

### 第四章：接口隔离原则

接口隔离原则（ISP）：客户端不应该被强迫依赖它不需要的接口，其中的客户端可以理解成为接口的调用者或使用者。

・把接口理解为一组API接口集合

​    需要单独提供的接口需要单独提供，不要强加给所有的客户端。

・把接口理解为单个API接口或函数

​    应该分成粒度更细的函数。

・把接口理解为OOP中的接口概念

​    不要让实现调用者调用无效接口。

※接口隔离与单一职责的区别，前者更注重对接口的设计。

### 第五章：依赖反转原则

依赖反转原则/依赖倒置原则（DIP）：高层模块不要依赖低层模块，高层模块和底层模块应该通过抽象来相互依赖。除此之外，抽象不要依赖具体实现细节，具体实现依赖抽象。

※主要用来指导框架层面的设计

控制反转（IOC）：原本应该是程序员控制代码，但是通过框架设计，让框架控制程序员编程。

依赖注入（DI）：不通过new 的方式实现类，而通过注入、传递等方式实现。

### 第六章：KISS原则和YAGNI原则

KISS原则：尽量保持简单。

※不是代码量越少就越简单，需要考虑可读性、编程复杂度等因素，综合考量。

编程过程中如何保持KISS原则？

・尽量不要写大家不懂的语法。

・尽量使用已有类库的功能。

・不要过度优化。

YAGNI原则：不要过度设计。

※只预留预留接口，不需要的功能不要提前实装，不要引用当前用不到的jar包。

### 第七章：DRY原则

DRY原则：不要写重复的代码。

・实现逻辑重复

例如：校验用户和校验密码，可能代码是完全相同的，但是由于业务逻辑不同，放到一起反而会违反单一原则，应该使用更小的粒度拆分共通逻辑。

・功能语义重复

例如：不同的开发者写出对同一实现写出不同的逻辑，虽然代码可能不一致，但是语义是相同的。

・代码执行重复

例如：虽然在不同的模块，但是都调用了密码校验，连接数据库等功能做相同操作。

如何提高代码复用性？

・减少代码耦合，越独立的模块越容易被复用

・满足单一职责原则

・代码模块化

・业务与非业务逻辑分离

・通用代码下沉

・四大原则

・设计模式

・要有复用的意识。

Rule  of  Three：只有第2/3次在开始考虑复用的问题。

### 第八章：迪米特法则

迪米特法则/最小知识原则（LOD）：每个模块只应该了解与它关系密切的模块的有限知识。

※为了实现高内聚、松耦合。高内聚是指类本身的设计（相近的功能放到同一个类，易于集中修改），松耦合用来指导类之前依赖关系的设计。

・不应该有直接依赖关系的类，不要有依赖。

例：简化版搜索引擎爬取网页功能（功能分成以下三个模块）：

1.网络通信类

2.html下载类

3.文档提取等相关处理类。

浅析：因为网络通信类是底层网络通信类，所以应该让其尽可能通用，而不是只为html服务，所以可以把两个类之间的依赖关系变为具体的字段，网络通信类只需要知道下载文档的"地址"和“数据”信息即可，松开网络通信类与html下载类之间的依赖关系。

・有依赖关系的类之间，尽量只依赖必要的接口。

例：序列化/反序列化

相对适合的解决方案：

①序列化类：serializer      

②反序列化类：deSerializer      

③序列化/反序列化类：serialization 实现serializer接口和deSerializer接口

### 实战一（上）

业务系统从需求分析到上线维护的整个开发过程-积分兑换系统。

要学会**借鉴**已有的程序和设计等。

1.需求分析

通过借鉴和迭代的方式进行需求分析，再通过线框图、用户用例、用户故事等来挖掘需求细节。

积分兑换系统功能需求：

・积分赚取和兑换规则

・积分消费和兑换规则

・积分及明细查询

2.系统设计

可以利用设计原则和模式来对系统进行设计。

①划分功能模块

推荐：积分系统只做增减积分和查询功能，其他内容放到上层的营销系统中去，做到业务和逻辑分离。

②设计模块间通信

・同步通信

・异步通信

③设计接口、数据库、业务模型

### 实战一（下）

为什么要分MVC三层开发？

①起到代码复用的作用，例如：共通Service。

②起到隔离变化的作用，利用抽象思想，每层改动不会影响或者很少影响其他层面的代码。

③起到单一原则，很清楚每层的意思。

④提高代码可测试性，例如：MOCK数据库。

⑤应该系统复杂性，当系统复杂到一定程度时，需要扩展。水平扩展就是模块化，垂直扩展就是分层。

VO、BO、Entity代码基本一致，要不要统一？

・还是会有差异在，例如：VO层不会存储Password。

・代码重复，但是语义不重复。

・减少耦合，责任明确。

可以通过继承和组合的方式减少代码重复。

3.代码实现

### 实战二（上）

非业务通用框架-性能计数器

1.需求分析

・功能性需求分析

通过线框图，将需求罗列出来，便于整理和分析。

・非功能性需求分析

①易用性->方便、文档

②性能->无明显影响性能

③扩展性->为框架拓展需求

④容错性->异常处理

⑤通用性

2.框架设计

利用TDD（测试驱动开发）和Protptype（最小原则），从一个**简单的原型**开始设计，不断迭代。

例如：写一个算法前，可以先做几组测试数据。

・数据采集

・存储：异步

・聚合统计

・显示

### 实战二（下）

小步快跑，逐步迭代。

3.代码实现

①通过职能划分不同的类（建模）

②定义属性和方法

③定义类之间的交互关系。

④将类拼装并提供入口

4.Review设计和实现

**※※※不断重构和优化。**

## 规范与重构

### 第一章

重构的目的、对象、时机和方法

1.目的：

・保证代码持续性的质量。

・最开始是简单的，需要重构迭代升级。

・避免初期过度设计。

・提高程序员的重构能力。

2.对象：

・大型重构（系统、模块、结构、类之间关系等）

・小型重构（类、函数、变量）

3.时机：

持续重构。

4.方法：

・大型重构方法

提前做好完善的重构计划，按阶段实现，完成一阶段，测试运行，保证每个阶段后代码都是可以正常运行的。

・小型重构（类、函数、变量）

可以借助检查工具。P3C、Findbugs，CheckStyle等。

### 第二章

保证重构手段-单元测试

1.什么是单元测试？

UT-代码层级的测试（JUnit等）

2.为什么要写单元测试？

保证质量最有效的两个手段之一： 单元测试和Code Review

①有效发现BUG

②能够发现设计的不足（不容易写单元测试）

③可以模拟很多难以在集合测试中实现的测试场景（例如网络超时、边界值等）。

④自我重构的过程

⑤能够快速帮助阅读人读懂功能。

⑥TDD-测试驱动开发

3.如果编写单元测试

利用测试框架（JUnit，TestNG、Spring test、Testing等）

※

・虽然繁琐，但不耗时

・可以稍微降低单元测试代码质量

・覆盖率不能完全代表质量

・不要依赖被测试代码的内部逻辑来编写单元测试。

・单元测试框架无法测试，多半是因为代码写的不好。

### 第三章

代码的可测试性-容易编写单元测试。

依赖注入是实现代码可测试性的最有效的手段。

通过Mock解依赖。

测试性不好的函数

・未决行为，结果输出不确定，例如时间，随机数等有关的代码。

・全局变量，执行顺序导致结果不一致。

・静态方法？  可用用PowerMock解决

・复杂继承关系

・高耦合代码，需要大量Mock代码，非常麻烦。

### 第四章

解耦

如何解耦:

・封装和抽象

・中间层，中间层也可以作为重构的过度作用。

・模块化-分而治之

・其他设计思想和原则

①单一职责

②基于接口编程

③依赖注入

④多组合少继承

⑤迪米特法则

### 编程规范（上）

・命名

1.长度

常用的缩写可以使用

作用域小的可以相对缩写

作用域大的尽量用长的

※能准确达意为目标

2.利用上下文简化命名

例如User.name, User.password

3.命名要可读、可搜索。

容易读写和记忆

风格统一，例如查询用SelectXXX，保存用insertXXX

4.命名接口和抽象类

项目统一

・注释

注释是命名的补充。

5.注释内容

格式：做什么-为什么-怎么做

6.注释是不是越多越好？

一般类和函数一定要写，函数内部通过命名来提高可读性。

### 编程规范（中）

・代码风格

7.类和函数的长度

过多阅读不便，过少需要多来回跳转，所以要适中。（推荐  函数：一竖屏的长度，类：200行）

8.代码行的长度

最长不要超过显示区域的长度，不要有滚动条，但也不要切分的过细，导致过多的折行。

9.善于使用空格分隔代码块

10.缩进

①四格缩进（PHP）

②两个缩进（Java），好处是多层缩进后，相对四格缩进，不易使代码折行。

※项目统一、遵从大厂的开源代码规则、不要用Tab键。

11.大括号是否要另起一行

①在代码最后：减少代码行数

②另起一行：开始和结束在一列，比较清晰的能区别代码块。

12.类中成员的排列顺序

依赖：按字母排列a-z

成员变量和函数：先静态，后普通

函数：按照作用域排序：public -> protected -> private

### 编程规范（下）

・编程技巧

13.把代码分割成更小的单元块

可以抽出方法，也可以利用第9条用空格区分。

14.避免参数过多

推荐不大于4个。

解决：可以通过划分更小粒度函数和将参数封装成对象两种方法。

15.不要用参数来控制函数。

例如用boolean型来区分函数执行内容是不被推荐的，可以分成不同的函数。

16.函数设计职责要单一

函数级别因为粒度比较小，最好做到尽可能的职责单一。

17.移除过深层次的嵌套

循环、判断等。

18.使用魔法值

19.使用解释性变量来解释复杂表达式

例如：IF语句中的判定式。

・统一编码规范

项目要做到编码规范统一，并通过Code Review督促执行。

### 实战一（上）

ID生成器-重构代码

如何发现代码质量问题？

①是否满足“高内聚、低耦合”

②是否遵循设计原则和设计思想

③是否过度设计

④是否易扩展

⑤是否可以复用

⑥是否易测试

⑦是否易读、符合编码规范

是否满足和业务相关的机能/非机能需求？

①是否符合业务需求

②逻辑是否正确，适用各种情况

③日志是否健全

④接口是否易用、是否符合幂等、事务等

⑤是否存在并发、线程是否安全

⑥性能是否可以优化

⑦是否有安全漏洞

### 实战一（下）

常用重构步骤：

①提高代码可读性

②提高代码可测试性

③编写单元测试

④添加注释

### 实战二（上）

函数异常返回

・返回错误码（C 语言）

・null

・空对象

・异常

①运行时异常->非受检异常（Runtime Exception）

②编译时异常->受检异常（Compile Exception）

### 实战二（下）

## 创建型设计模式

### 单例模式（上）

单例设计模式（Singleton Design Pattern）：一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。

**单例的用处**

・处理资源访问冲突

・表示全局唯一类

**单例的因素**

・构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；

・考虑对象创建时的线程安全问题；

・考虑是否支持延迟加载；

・考虑 getInstance() 性能是否高（是否加锁）。

**单例的实现**

・饿汉式：在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载。

・懒汉式：支持延迟加载，但是有性能问题，不支持高并发。

・双重检测：支持延迟加载、又支持高并发的单例实现方式。先检查是否创建，null的情况就创建，否则就不会创建。

・静态内部类：。它有点类似饿汉式，但又能做到了延迟加载。外部类首先被加载，但是内部静态类不会会创建，只有在调用外部类的方法时，才创建内部静态类中的示例。

・枚举：通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。

### 单例模式（中）

**单例存在哪些问题**

・单例对 OOP 特性的支持不友好（能做，但是比较怪异）

・单例会隐藏类之间的依赖关系（可读性差）

・单例对代码的扩展性不友好（可扩展性差），连接池等还是不做成单例会比较好，易扩展。

・单例对代码的可测试性不友好（可测试性差）

・单例不支持有参数的构造函数（因为只有第一次的参数被使用了，但是因为实例已经创建，所以后续的却没有使用。而且会使使用者误会。）

**替代解决方案**

・静态方法（部分解决）

・工厂模式

・IOC 容器

・程序员自己保证？

### 单例模式（下）

线程唯一是通过ThreadLocal(底层：HashMap("线程 ID","对象"))。

进程唯一还代表了线程内、线程间都唯一。单例模式创建的对象是进程唯一的。

集群唯一就是进程内唯一、进程间也唯一。（我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件））

多例模式指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。（例如枚举类型）

### 工厂模式（上）

工厂模式（Factory Design Pattern）

・简单工厂（Simple Factory）

・工厂方法（Factory Method）

・抽象工厂（Abstract Factory）

何时使用工厂方法而不是简单工厂

①创建过程涉及复杂的 if-else 分支判断。

②对象创建需要组装多个其他类对象或者需要复杂的初始化过程。

### 工厂模式（下）

DI 容器底层最基本的设计思路就是基于工厂模式的。BeansFactory

DI 容器的核心功能

・配置解析 @Bean

・对象创建

・对象生命周期管理

​    scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象。

​    lazy-init=true，对象在真正被使用到的时候才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好。

​    init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。

BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法

### 建造者模式

Builder Pattern

如果可配置项过多，就容易搞错各参数的顺序；

如果用构造方法+set方法的不足：1、必填项过多的话，2、校验，3、创建后不可变，4、可能会出现短暂的无效状态。

工厂模式和建造者模式的区别：

・工厂模式根据参数创造不同但相关的对象

・建造者模式根据可选参数定制化一种类型的复杂化对象。

### 原型模式

原型模式（Prototype Design Pattern）：利用对已有对象（原型）进行拷贝的方式来创建新对象。

深拷贝和浅拷贝

重新创建成本较大的情况下在考虑使用原型模式

浅拷贝：内存地址，索引

深拷贝：值，深层对象

深拷贝方式：1、递归拷贝对象；2、先将对象序列化，然后再反序列化成新的对象。

## 结构型设计模式

### 代理模式

代理模式（Proxy Design Pattern）：它在不改变原始类代码的情况下，通过引入代理类来给原始类附加功能。

实现代理

①代理类和被代理类实现同一接口

②代理类继承被代理类

③动态代理：AOP底层就是动态代理

代理模式常用在业务系统中开发一些非功能性需求。

### 桥接模式

桥接模式（Bridge Design Pattern）：将抽象和实现解耦，让它们可以独立变化，通过组合将其链接在一起。类似“组合优于继承”

JDBC 驱动是桥接模式的经典应用。

### 装饰器模式

装饰器模式：它的代码结构跟桥接模式非常相似，不过，要解决的问题却大不相同。

Java IO应用了装饰器模式（InputStream）

装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。

做一个增强功能的抽象方法，需要的都实现它。

### 适配器模式

适配器模式（Adapter Design Pattern）：将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。(USB转接头)

实现：

・类适配器: 基于继承

・对象适配器：基于组合

应用场景：

・封装有缺陷的接口设计，二次封装

・统一多个类的接口设计，同一成相同的调用逻辑，使调用更加简单同一

・替换依赖的外部系统

・兼容老版本接口，标注为“deprecated”

・适配不同格式的数据，Arrays.asList()

经典模式：Slf4j

代理、桥接、装饰器、适配器 4 种设计模式的区别：它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。

・代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。

・桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。	

・装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。

・适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。

### 门面模式

门面模式/外观模式（ Facade Design Pattern）：门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。

接口设计的粒度，组合细粒度接口，组合不同service到controller

应用场景：

①解决易用性：可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。Linux和shell

②解决性能：较少通信次数。

③解决分布式事务：两个不同的业务模型，但是必须在同一个事务中，可以通过门面模式将两个业务放到一个接口中，使用同一事物。

接口设计在可重用的基础进行划分，可以通过门面模式进行组合。

### 组合模式

组合模式（Composite Design Pattern）：主要是用来处理树形结构数据。

叶子节点

### 享元模式（上）

享元模式（Flyweight Design Pattern）：共享单元，复用对象，前提使不可变对象

可以全共享或者部分共享，减少对象，节省内存。

享元模式跟单例的区别：

单例模式：一个类只能创建一个对象。

享元模式：一个类可以创建多个对象(类似多例)，对象复用，节省内存。

享元模式跟缓存的区别：

缓存主要是为了提高访问效率，而非复用

享元模式跟对象池的区别：

池化技术：独占复用对象

享元模式：共享使用

### 享元模式（下）

Integer的自动装箱/自动拆箱使用了享元模式，最开始自动生成256个对象。

String字符串常量池使用了享元模式，第一次使用后会放到字符串常量池，再次使用的时候会直接从字符串常量池中取。

new的话就不使用享元模式了。

元模式对 JVM 的垃圾回收并不友好。因为享元工厂类一直保存了对享元对象的引用，不要过度使用。

## 行为型设计模式

### 观察者模式（上）

观察者模式（Observer Design Pattern）也被称为发布订阅模式（Publish-Subscribe Design Pattern）：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。

设计模式要干的事情就是解耦。

邮件订阅是通过观察者模式实现的。

同步阻塞实现方式和异步非阻塞实现方式

被观察者->消息队列->观察者

### 观察者模式（下）

框架的作用有：隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。

Google Guava EventBus：事件总线，它提供了实现观察者模式的骨架代码；

EventBus eventBus = new EventBus(); // 同步阻塞模式

EventBus eventBus = new AsyncEventBus(Executors.newFixedThreadPool(8))；// 异步阻塞模式

EventBus 类提供了 register() 函数用来注册观察者。

unregister() 函数用来从 EventBus 中删除某个观察者。

EventBus 类提供了 post() 函数，用来给观察者发送消息。

EventBus 通过 @Subscribe 注解来标明，某个函数能接收哪种类型的消息。

⭐CopyOnWriteArraySet，顾名思义，在写入数据的时候，会创建一个新的 set，并且将原始数据 clone 到新的 set 中，在新的 set 中写入数据完成之后，再用新的 set 替换老的 set。这样就能保证在写入数据的时候，不影响数据的读取操作，以此来解决读写并发问题。除此之外，CopyOnWriteSet 还通过加锁的方式，避免了并发写冲突。

### 模板模式（上）

模板模式（Template Method Design Pattern）：模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。

绝大部分设计模式的原理和实现，都非常简单，难的是掌握应用场景，搞清楚能解决什么问题。

模板模式有两大作用：复用和扩展。

Java(InputStream、OutputStream、Reader、Writer)、AbstractList、Junit TestCase、Java Servlet

模板方法定义为 final，可以避免被子类重写。需要子类重写的方法定义为 abstract，可以强迫子类去实现。不过，在实际项目开发中，模板模式的实现比较灵活，以上两点都不是必须的。

InstantiationAwareBeanPostProcessorAdapter类：

InstantiationAwareBeanPostProcessor代表了Spring的另外一段生命周期：实例化。先区别一下Spring Bean的实例化和初始化两个阶段的主要作用：

1、实例化—-实例化的过程是一个创建Bean的过程，即调用Bean的构造函数，单例的Bean放入单例池中

2、初始化—-初始化的过程是一个赋值的过程，即调用Bean的setter，设置Bean的属性

### 模板模式（下）

回调（Callback）：跟模板模式相同的作用（复用和扩展）

BClass b = new BClass();

b.process(new ICallback() { //回调对象

​    @Override

​    public void methodToCallback() {

​        System.out.println("Call back me.");

​    }

});

JdbcTemplate（各种Template）：回调，重写execute()方法

setClickListener(）

addShutdownHook()：Tomcat 和 JVM 的 shutdown hook

模板模式和回调的区别：

模板模式基于继承

回调基于组合

组合优于继承，所以回调模板模式：回调组合多个，但继承只能一个；回调可以使用匿名类来创建回调对象；回调更灵活，不用实现所有抽象方法。

### 策略模式

策略模式（Strategy Design Pattern）：定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。

利用它来避免冗长的 if-else 或 switch 分支判断。

1. 策略的定义，包含一个策略接口和一组实现这个接口的策略类。

2. 策略的创建，包含一组策略，通过类型（type）来判断创建哪个策略来使用。

3. 策略的使用，运行时动态确定使用哪种策略。

通过type从工厂类中创建策略类。

### 职责链模式（上）

职责链模式（Chain Of Responsibility Design Pattern）：依此执行链条上的每个节点的处理器。

只处理自己节点的逻辑，不依赖其他节点的数据。

将大块代码逻辑拆分成函数，将大类拆分成小类，是应对代码复杂性的常用方法。

循环职责链数组，可以不修改源码，且更加灵活。

职责链模式有两种常用的实现。一种是使用链表来存储处理器，另一种是使用数组来存储处理器，后面一种实现方式更加简单。

### 职责链模式（下）

SpringMVC的核心就是DispatcherServlet，DispatcherServlet实质也是一个HttpServlet。DispatcherSevlet负责将请求分发，所有的请求都有经过它来统一分发。

**Servlet Filter**：FilterChain 就是处理器链，doFilter()方法

通过Filter、OncePerRequestFilter来实现的。

**Spring Interceptor**：客户端发送的请求，会先经过 Servlet Filter，然后再经过 Spring Interceptor，最后到达具体的业务代码中。

HandlerExecutionChain 类是职责链模式中的处理器链。

通过HandlerInterceptor 来实现的

Filter 可以拿到原始的http请求，但是拿不到你请求的控制器和请求控制器中的方法的信息; Interceptor 可以拿到你请求的控制器和方法，却拿不到请求方法的参数; Aop 可以拿到方法的参数，但是却拿不到http请求和响应的对象

spring filter 作用于容器，应用范围影响最大；spring interceptor 作用于框架，范围影响适中；aop 作用于业务逻辑，精细化处理，范围影响最小。

### 状态模式

状态模式一般用来实现状态机/有限状态机，而状态机常用在游戏、工作流引擎等系统开发中。

状态机（Finite State Machine）：有 3 个组成部分：状态（State）、事件/转移条件（Event）、动作（Action）。

实现方式：

1.分支逻辑法：if...else

2.查表法:通过索引直接找到二维数组（状态/事件）中的动作。

3.状态模式，定义状态接口类，接口内定义事件。不同的状态类继承状态接口，完成动作。

### 迭代器模式（上）

迭代器模式（Iterator Design Pattern）:用来遍历集合对象。

遍历集合数据有三种方法：for 循环、foreach 循环、iterator 迭代器。（foreach 循环本质是迭代器模式）

面向接口编程，可以根据不同的算法遍历。（比如深度优先、广度优先等）

### 迭代器模式（中）

删除/添加集合元素有不确定因素，因为删除/添加元素会导致指针/引用地址变换。未决行为/不可预期行为

### 迭代器模式（下）

快照功能：并非复制容器，可以给每个元素和容器分别添加时间戳，类似逻辑删除。

### 访问者模式（上）

访问者模式（Visitor Design Pattern）：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。(将pdf、xml等解析成txt)

通过重载，根据访问者对象不同，实现不同的方法。

访问者模式针对的是一组类型不同的对象。但是，它们继承相同的父类或者实现相同的接口。我们使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类中。

①对象抽象类，定义抽象方法（入参是操作接口类）

②操作接口类，定义方法（根据不同的对象实现类作为参数进行重载）

③对象实现类，继承对象抽象类，实现抽象方法，在抽象方法中调用操作接口类的抽象方法，并将自己this作为参数传进去。

④操作实现类，实现操作接口类，分别编写具体的逻辑。

⑤调用对象实现类的实现的抽象方法，将要执行的操作类作为参数传进去，在抽象方法内将this传到操作类中进行具体操作。

### 访问者模式（下）

双分派（Double Dispatch）

Single Dispatch 之所以称为“Single”，是因为执行哪个对象的哪个方法，只跟“对象”的运行时类型有关。Double Dispatch 之所以称为“Double”，是因为执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关。

当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch。

### 备忘录模式

备忘录模式/快照（Snapshot）模式（Memento Design Pattern）：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。

主要是用来防丢失、撤销、恢复等

“低频率全量备份”、“高频率增量备份”、“低频率全量备份”和“高频率增量备份”相结合的方法。

### 命令模式

命令模式（Command Design Pattern）：命令模式将命令封装为一个对象，将不同请求依赖注入到其他对象，并且能够支持命令的排队执行、记录日志、撤销等附加控制功能。

类似与回调，将命令（函数）包装在对象中，通过传递对象来实现命令的传递。

①命令接口类，创建抽象方法

②执行方法的时候，将参数和实现类一同传递

③执行抽象方法

每个设计模式都是基于设计原则编写的，所以会有相似的感觉，其实还是需要看这种设计模式的应用场景。

命令模式比较适用于异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等。

### 解释器模式

解释器模式（Interpreter Design Pattern）：为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。

用来实现根据语法**规则**解读“句子”的解释器。

举例：语言翻译器、表达式、正则

### 中介模式

中介模式（Mediator Design Pattern）：中介模式定义了一个单独的对象，来封装一组对象之间的交互。

类似中间层的概念，从N对N的网状关系转到N对1的星状关系。

经典例子：航空管制，中介=塔台

如果交互关系很有条理可以使用观察者模式，如果交互关系很混乱或者有顺序要求可以使用中介模式。

## 过度设计/设计不足

设计的初衷是提高代码质量，所以每种设计都应该有它的意义。

先有问题后有方案，先搞清楚的需求、痛点，在通过设计来解决这些问题。

应用于复杂的应用场景，将复杂的代码进行解耦。

## 开源实战

### Java JDK源码

・工厂模式/建造者模式在 Calendar 类中的应用（java.util.Calendar）

提供了getInstance() 工厂方法

提供了Builder() 建造者模式

功能代码和工厂方法代码耦合在了一个类中

・装饰器模式/适配器模式/模板模式在 Collections 类中的应用

UnmodifiableCollection 的构造函数接收一个 Collection 类对象，然后对其所有的函数进行了包裹：重新实现或者简单封装（比如 stream() 函数）。

Enumeration 类是适配器类

Collections 类的 sort(Object, Comparator<Object>) 函数就是利用了模板模式的这个扩展特性。

・观察者模式在 JDK 中的应用(java.util.Observable 和 java.util.Observer)

依次调用 setChanged() 和 notifyObservers() 两个函数

・单例模式在 Runtime 类中的应用

每个 Java 应用在运行时会启动一个 JVM 进程，每个 JVM 进程都只对应一个 Runtime 实例，用于查看 JVM 状态以及控制 JVM 行为。进程内唯一，所以比较适合设计为单例。

### Unix开源

・开发原则

①封装与抽象

②分层与模块化（微服务？）

分层：内核、系统调用、应用层

③基于接口通信

④高内聚、松耦合

代码改动集中，修改处bug的可能性就会降低

⑤为扩展而设计

⑥KISS 为首要原则，尽量简单，可读性好。

⑦最小惊奇原则

※遵守开发规范

・保证代码质量，让代码长期可维护。

①吹毛求疵般地执行编码规范※

②编写高质量的单元测试※

③Code Review※

④技术文档

⑤持续重构※

⑥拆分小团队，每个小团队对自己的任务负责。

・Code Review的作用

①三人行必有我师，每个人都有Review的资格，都有可能从不同的角度给出意见，要尊重每个人的意见。

②水桶的容积是由最短的木板所决定的，整体的进步才会推动团队水平的提升。

③提高可读性。

④一带一，极有效的技术能提提升方式。

⑤让更多的人熟悉编写的代码。

⑥创建良好的技术氛围。

⑦是一种技术沟通方式

⑧能提高团队的自律性

### Google Guava

![img](https://static001.geekbang.org/resource/image/1c/45/1ce23ffd03045dadf2bad7e126337045.png)

・在业务开发中，跟业务无关的通用功能模块，常见的一般有三类：类库（library）、框架（framework）、功能组件（component）等。

・把通用功能模块当成产品来做，能提供给更多的项目用，目标用户事程序员，解决开发痛点。

・通用功能模块可以先从项目内做起，但是要尽量和业务解耦抽象，在其他项目有需求，可以独立出来做成类库、框架或者功能组件。

・阅读Google Guava 的开源代码，可以学习Google 公司的开发经验、编码规范、单元测试等。

・Builder 模式在 Guava 中的应用（缓存）

com.google.common.cache.*。

~~~~
public class CacheDemo {
  public static void main(String[] args) {
    Cache<String, String> cache = CacheBuilder.newBuilder()
            .initialCapacity(100)
            .maximumSize(1000)
            .expireAfterWrite(10, TimeUnit.MINUTES)
            .build();
    cache.put("key1", "value1");
    String value = cache.getIfPresent("key1");
    System.out.println(value);
  }
}
~~~~

Builder 模式可以对创建对象的初始参数进行校验，保证创建的对象一定符合创建要求。

・Wrapper 模式在 Guava 中的应用（代理模式、装饰器、适配器模式可以统称为 Wrapper 模式，通过 Wrapper 类二次封装原始类。）

部分方法代理。

・Immutable 模式在 Guava 中的应用（不变模式，经典设计模式以外）

不变模式：一个对象的状态在对象创建之后就不再改变，包括不变类和不变对象等。例如String。

不变模式常用在多线程环境下，来避免线程加锁。

Google Guava 针对集合类提供的对应的不变集合类（ImmutableCollection、ImmutableList、ImmutableSet、ImmutableMap…）。

Java JDK 提供的不变集合类（UnmodifiableCollection、UnmodifiableList、UnmodifiableSet、UnmodifiableMap…）。

・主流的编程范式主要有三种，面向过程、面向对象和函数式编程。

・函数式编程

函数式编程：以函数作为组织代码的单元，数据与方法相分离。

函数的执行结果只与入参有关，跟其他任何外部变量无关。同样的入参，不管怎么执行，得到的结果都是一样的。类似于Utils方法。

Java中函数式编程：Stream 类、Lambda 表达式和函数接口。

### Spring框架

・我们常说的 Spring 框架，是指 Spring Framework 基础框架。Spring Framework 是整个 Spring 生态（也被称作 Spring 全家桶）的基石。除了 Spring Framework，Spring 全家桶中还有更多基于 Spring Framework 开发出来的、整合更多功能的框架，比如 Spring Boot、Spring Cloud。Spring Boot 是基于 Spring Framework 开发的。它更加专注于微服务开发。之所以名字里带有“Boot”一词，跟它的设计初衷有关。Spring Boot 的设计初衷是快速启动一个项目，利用它可以快速地实现一个项目的开发、部署和运行。Spring Boot 支持的所有功能都是围绕着这个初衷设计的，比如：集成很多第三方开发包、简化配置（比如，规约优于配置）、集成内嵌 Web 容器（比如，Tomcat、Jetty）等。单个的微服务开发，使用 Spring Boot 就足够了，但是，如果要构建整个微服务集群，就需要用到 Spring Cloud 了。Spring Cloud 主要负责微服务集群的服务治理工作，包含很多独立的功能组件，比如 Spring Cloud Sleuth 调用链追踪、Spring Cloud Config 配置中心等。

・利用框架的好处是简化开发

・Spring优势

① 约定优于配置

配置的两种方式：一种是基于注解，另一种是基于约定

二八法则：80%的默认配置、20%的显示配置。（超多场景都可以适用的二八法则）

②低侵入、松耦合

框架和业务代码松耦合，便于更换框架。

③模块化、轻量级

可以有选择的引入不同模块的框架。

④再封装、再抽象

封装了很多主流的中间件和类库，更便于适用其他中间件和类库。

・观察者模式在 Spring 中的扩展

Spring 中实现的观察者模式包含三部分：Event 事件（相当于消息）、Listener 监听者（相当于观察者）、Publisher 发送者（相当于被观察者）。

~~~~~

// Event事件
public class DemoEvent extends ApplicationEvent {
  private String message;

  public DemoEvent(Object source, String message) {
    super(source);
  }

  public String getMessage() {
    return this.message;
  }
}

// Listener监听者
@Component
public class DemoListener implements ApplicationListener<DemoEvent> {
  @Override
  public void onApplicationEvent(DemoEvent demoEvent) {
    String message = demoEvent.getMessage();
    System.out.println(message);
  }
}

// Publisher发送者
@Component
public class DemoPublisher {
  @Autowired
  private ApplicationContext applicationContext;//事件总线

  public void publishEvent(DemoEvent demoEvent) {
    this.applicationContext.publishEvent(demoEvent);
  }
}
~~~~~

・模板模式在 Spring 中的扩展

Spring 提供了一个定义初始化函数的方法，那就是让类实现 Initializingbean 接口。这个接口包含一个固定的初始化函数定义（afterPropertiesSet() 函数）。Spring 在初始化 Bean 的时候，可以直接通过 bean.afterPropertiesSet() 的方式，调用 Bean 对象上的这个函数。

BeanPostProcessor：bean初始化接口

・适配器模式在 Spring 中的应用

在应用启动的时候，Spring 容器会加载这些 Controller 类，并且解析出 URL 对应的处理函数，封装成 Handler 对象，存储到 HandlerMapping 对象中。当有请求到来的时候，DispatcherServlet 从 HanderMapping 中，查找请求 URL 对应的 Handler，然后调用执行 Handler 对应的函数代码，最后将执行结果返回给客户端，用到了模板模式。

・策略模式在 Spring 中的应用

Spring 支持两种动态代理实现方式，一种是 JDK 提供的动态代理实现方式，另一种是 Cglib 提供的动态代理实现方式，用到了模板模式。

・组合模式在 Spring 中的应用

Cache中应用了组合模式，主要应用在能表示成树形结构的一组数据上。树中的结点分为叶子节点和中间节点两类。对应到 Spring 源码，EhCacheManager、SimpleCacheManager、NoOpCacheManager、RedisCacheManager 等表示叶子节点，CompositeCacheManager 表示中间节点。

・装饰器模式在 Spring 中的应用

缓存一般都配合数据库使用，需要在同一个事物，可以利用装饰器模式，TransactionAwareCacheDecorator类实现缓存对事务的支持。

・工厂模式在 Spring 中的应用

IOC容器：BeanFactory 类和 ApplicationContext 相关类

・SpEL:表达式语言

### MyBatis

・ORM框架：负责将程序中的对象存储到数据库中、将数据库中的数据转化为程序中的对象。

・JdbcTemplate 更加轻量级，但是SQL 与代码耦合在一起，而且不具备 ORM 的功能

・Hibernate 更加重量级，但是灵活性差。

・MyBatis 介于两者中间，在易用性、性能、灵活性三个方面做到了权衡。

・实现 MyBatis 的 Interceptor 接口，并且，在 MyBatis 的全局配置文件中，简单声明一下这个插件就可以了。

・@Intercepts：明确地标明拦截的目标方法

・@Signature：嵌套在@Intercepts标签里，可编写多个。

・MyBatis Plugin 允许拦截的方法

・MyBatis Plugin通过职责链（Chain）和动态代理实现。

## 项目实战

### 支持各种算法的限流框架

#### 分析

①画线框图、写用户用例、测试驱动开发等等

②设置限流规则：配置文件

③提供编程接口验证请求是否被限流

④易用性:不同中间价、框架

⑤扩展性、灵活性:不同格式、不同数据源

⑥性能:不能影响性能

⑦容错性：稳定性要好。

*多考虑非功能性需求。

#### 设计

①限流规则

遵循最小惊奇准则，将配置配置到配置文件中，放到默认的位置。

限流的粒度 1秒1000次≠10毫秒10次，因为有可能在1毫秒内达到1000次的可能。也不能将粒度设置的过小，可能会屏蔽掉一些不该屏蔽掉的请求。

②限流算法

算法很多，大多是通过时间和单位时间内次数来进行计算。

③限流模式

限流对象单机限流和分布式限流。

对单个实例的某个接口的访问频率，不能超过 100 次 / 秒。这就是单机限流。

对 5 个实例的某个接口的总访问频率，不能超过 500 次 / 秒。这就是所谓的分布式限流。

*设计合适的超时时间

④集成使用

和业务代码低侵入松耦合。

*允许短时间、小规模异常带来的影响。

#### 实现

小步快跑、逐步迭代

①V1 版本，包含核心功能、基本功能。

②MVP 代码（最小原型代码），不考虑规范等要素，先实现功能。

③Review 最小原型代码

④重构最小原型代码

### 通用的接口幂等框架

#### 分析

・幂等框架是指针对同一个接口，多次发起同一个业务请求（重试），必须保证业务只执行一次。

・HTTP方法是*幂等*的,指的是同样的请求被执行一次与连续执行多次的效果是一样的,服务器的状态也是一样的。无副作用。

・查询、删除、更新这些操作，那接口天然是幂等。

・幂等号：同一业务请求一个唯一标识。

・判断幂等号是否存在，存在的话不执行，不存在的话，存入幂等号后执行。

#### 设计

・异常处理

①业务代码异常处理,是否可以重试（分为系统异常和业务异常）应该由业务工程师来决定。

②业务系统宕机处理，可以将幂等号存入数据库，将幂等号保存和相关业务操作放在同一个事务中。

③幂等框架异常处理，框架出问题的话，直接将让请求失败处理，修复成本小。

#### 实现

・功能

实现生成幂等号的功能（全局唯一 ID，例如UUID）；

实现存储、查询、删除幂等号的功能。

※思从深而行从简

### 自定义规则的灰度发布组件

#### 分析

灰度：新老框架、业务、产品、系统、代码交替过程中，逐步放亮的过程。灰度达到100%后并运行一段时间可以完全替换老系统。过程中发现问题，及时回滚到老系统。

#### 设计

设计灰度规则。

#### 实现

①灰度规则的格式和存储方式

不同格式（JSON、YAML、XML 等）、不同存储方式（本地配置文件、Redis、Zookeeper、或者自研配置中心等）的灰度规则配置方式。

②灰度规则的语法格式

三种灰度规则语法格式：具体值（比如 893）、区间值（比如 1020-1120）、比例值（比如 %30）。除此之外，对于更加复杂的灰度规则，比如只对 30 天内购买过某某商品并且退货次数少于 10 次的用户进行灰度，将通过编程的方式来实现。（也可以使用Drools 规则引擎）

③灰度规则的内存组织方式

设计成支持快速查找的数据结构，便于快速查找。

④灰度规则热更新

先搭建框架，在添加、丰富内容。

